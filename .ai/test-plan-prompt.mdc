---
description: 
globs: 
alwaysApply: false
---
Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu programistycznego. Przeanalizuj poniższe informacje o projekcie:

<kod_projektu>
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: src/env.d.ts
================================================
/// <reference types="astro/client" />

import type { SupabaseClient } from './db/supabase.client.ts';
import type { ProfileDTO } from './types.ts';

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient;
      user?: {
        id: string;
        email: string;
      };
      profile?: ProfileDTO;
    }
  }
}

interface ImportMetaEnv {
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly SUPABASE_SERVICE_ROLE_KEY: string;
  readonly PROD: boolean;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
FILE: src/types.ts
================================================
/**
 * Data Transfer Objects (DTOs) and Command Models for Cook Mastery API
 * 
 * This file contains all type definitions for API requests and responses.
 * All types are derived from database entity definitions in database.types.ts
 */

import type { Tables, TablesInsert, TablesUpdate, Enums } from './db/database.types';

// ============================================================================
// Base Entity Types (Re-exported from database types)
// ============================================================================

export type ArticleEntity = Tables<'articles'>;
export type TutorialEntity = Tables<'tutorials'>;
export type ProfileEntity = Tables<'profiles'>;
export type CookbookEntryEntity = Tables<'cookbook_entries'>;
export type UserArticleEntity = Tables<'user_articles'>;
export type UserTutorialEntity = Tables<'user_tutorials'>;
export type UserLevelProgressEntity = Tables<'user_level_progress'>;

export type DifficultyLevel = Enums<'difficulty_level'>;
export type TutorialCategory = Enums<'tutorial_category'>;

// ============================================================================
// Tutorial Step Type
// ============================================================================

/**
 * Represents a single step within a tutorial.
 * Extracted from the JSONB steps column in tutorials table.
 */
export interface TutorialStep {
  title: string;
  content: string;
  order: number;
}

// ============================================================================
// Pagination Types
// ============================================================================

/**
 * Standard pagination metadata returned with all list endpoints
 */
export interface PaginationMeta {
  page: number;
  limit: number;
  total_items: number;
  total_pages: number;
}

/**
 * Query parameters for paginated endpoints
 */
export interface PaginationParams {
  page?: number;
  limit?: number;
}

// ============================================================================
// Tutorial DTOs
// ============================================================================

/**
 * Tutorial list item DTO - used in GET /api/tutorials
 * Includes completion status when user is authenticated
 */
export interface TutorialListItemDTO
  extends Pick<
    TutorialEntity,
    'id' | 'title' | 'category' | 'level' | 'difficulty_weight' | 'summary' | 'created_at'
  > {
  is_completed: boolean;
}

/**
 * Tutorial detail DTO - used in GET /api/tutorials/:id
 * Includes full content and completion information
 */
export interface TutorialDetailDTO
  extends Pick<
    TutorialEntity,
    | 'id'
    | 'title'
    | 'category'
    | 'level'
    | 'difficulty_weight'
    | 'summary'
    | 'content'
    | 'practice_recommendations'
    | 'key_takeaways'
    | 'created_at'
    | 'updated_at'
  > {
  steps: TutorialStep[];
  is_completed: boolean;
  completed_at: string | null;
}

/**
 * Query parameters for GET /api/tutorials
 */
export interface ListTutorialsParams extends PaginationParams {
  level?: DifficultyLevel;
  category?: TutorialCategory;
  sort?: 'difficulty_asc' | 'newest';
  include_completed?: boolean;
}

/**
 * Response DTO for GET /api/tutorials
 */
export interface ListTutorialsResponseDTO {
  tutorials: TutorialListItemDTO[];
  pagination: PaginationMeta;
}

/**
 * Response DTO for GET /api/tutorials/:id
 */
export type GetTutorialDetailResponseDTO = TutorialDetailDTO;

// ============================================================================
// Article DTOs
// ============================================================================

/**
 * Article list item DTO - used in GET /api/articles
 * Includes completion status when user is authenticated
 */
export interface ArticleListItemDTO
  extends Pick<
    ArticleEntity,
    'id' | 'title' | 'level' | 'difficulty_weight' | 'summary' | 'created_at'
  > {
  is_completed: boolean;
  completed_at: string | null;
}

/**
 * Article detail DTO - used in GET /api/articles/:id
 * Includes full content and completion information
 */
export interface ArticleDetailDTO
  extends Pick<
    ArticleEntity,
    | 'id'
    | 'title'
    | 'level'
    | 'difficulty_weight'
    | 'summary'
    | 'content'
    | 'key_takeaways'
    | 'created_at'
    | 'updated_at'
  > {
  is_completed: boolean;
  completed_at: string | null;
}

/**
 * Query parameters for GET /api/articles
 */
export interface ListArticlesParams extends PaginationParams {
  level?: DifficultyLevel;
  sort?: 'difficulty_asc' | 'newest';
  include_completed?: boolean;
}

/**
 * Response DTO for GET /api/articles
 */
export interface ListArticlesResponseDTO {
  articles: ArticleListItemDTO[];
  pagination: PaginationMeta;
}

/**
 * Response DTO for GET /api/articles/:id
 */
export type GetArticleDetailResponseDTO = ArticleDetailDTO;

// ============================================================================
// Cookbook Entry DTOs
// ============================================================================

/**
 * Cookbook entry DTO - used for all cookbook endpoints
 * Represents a saved recipe link with optional notes
 */
export type CookbookEntryDTO = Pick<
  CookbookEntryEntity,
  'id' | 'user_id' | 'url' | 'title' | 'notes' | 'created_at' | 'updated_at'
>;

/**
 * Query parameters for GET /api/cookbook
 */
export interface ListCookbookEntriesParams extends PaginationParams {
  sort?: 'newest' | 'oldest' | 'title_asc';
}

/**
 * Response DTO for GET /api/cookbook
 */
export interface ListCookbookEntriesResponseDTO {
  entries: CookbookEntryDTO[];
  pagination: PaginationMeta;
}

/**
 * Response DTO for GET /api/cookbook/:id
 */
export type GetCookbookEntryResponseDTO = CookbookEntryDTO;

/**
 * Command model for POST /api/cookbook
 * Creates a new cookbook entry for the authenticated user
 */
export interface CreateCookbookEntryCommand
  extends Pick<TablesInsert<'cookbook_entries'>, 'url' | 'title' | 'notes'> {}

/**
 * Command model for PATCH /api/cookbook/:id
 * Updates an existing cookbook entry (all fields optional)
 */
export interface UpdateCookbookEntryCommand
  extends Partial<Pick<TablesUpdate<'cookbook_entries'>, 'url' | 'title' | 'notes'>> {}

/**
 * Response DTO for POST /api/cookbook
 */
export type CreateCookbookEntryResponseDTO = CookbookEntryDTO;

/**
 * Response DTO for PATCH /api/cookbook/:id
 */
export type UpdateCookbookEntryResponseDTO = CookbookEntryDTO;

/**
 * Response DTO for DELETE /api/cookbook/:id
 */
export interface DeleteCookbookEntryResponseDTO {
  message: string;
}

// ============================================================================
// Profile DTOs
// ============================================================================

/**
 * Profile DTO - represents user profile information
 */
export type ProfileDTO = Pick<
  ProfileEntity,
  'id' | 'username' | 'selected_level' | 'created_at' | 'updated_at'
>;

/**
 * Command model for updating user profile
 * All fields are optional to support partial updates
 */
export interface UpdateProfileCommand
  extends Partial<Pick<TablesUpdate<'profiles'>, 'username' | 'selected_level'>> {}

// ============================================================================
// User Progress DTOs
// ============================================================================

/**
 * Level progress DTO - represents completion progress for a specific difficulty level
 * Derived from user_level_progress view
 */
export interface LevelProgressDTO {
  level: DifficultyLevel;
  total_count: number;
  completed_count: number;
  completion_percent: number;
  is_up_to_date: boolean;
}

/**
 * User progress summary DTO - aggregates progress across all levels
 */
export interface UserProgressSummaryDTO {
  user_id: string;
  selected_level: DifficultyLevel;
  level_progress: LevelProgressDTO[];
  can_advance: boolean; // true if completion_percent >= 85% and selected_level != 'EXPERIENCED'
}

/**
 * Command model for POST /api/tutorials/:id/complete
 * Records tutorial completion for the authenticated user
 */
export type CompleteTutorialCommand = Pick<TablesInsert<'user_tutorials'>, 'tutorial_id'>;

/**
 * Response DTO for POST /api/tutorials/:id/complete
 */
export interface CompleteTutorialResponseDTO {
  tutorial_id: string;
  user_id: string;
  completed_at: string;
  status: 'created' | 'already_completed';
}

/**
 * Command model for POST /api/articles/:id/complete
 * Records article completion for the authenticated user
 */
export type CompleteArticleCommand = Pick<TablesInsert<'user_articles'>, 'article_id'>;

/**
 * Response DTO for POST /api/articles/:id/complete
 */
export interface CompleteArticleResponseDTO {
  article_id: string;
  user_id: string;
  completed_at: string;
  status: 'created' | 'already_completed';
}

// ============================================================================
// Authentication DTOs
// ============================================================================

/**
 * Command model for user signup
 * Combines Supabase Auth requirements with profile creation
 */
export interface SignUpCommand {
  email: string;
  password: string;
  username: string;
  selected_level: DifficultyLevel;
}

/**
 * Response DTO for successful signup
 * Returns user and profile information
 * Session is managed via HttpOnly cookies (not exposed to client)
 */
export interface SignUpResponseDTO {
  user: {
    id: string;
    email: string;
  };
  profile: ProfileDTO;
}

/**
 * Command model for user login
 * Accepts either email or username as identifier
 */
export interface LoginCommand {
  identifier: string; // email or username
  password: string;
}

/**
 * Response DTO for successful login
 * Session is managed via HttpOnly cookies (not exposed to client)
 */
export interface LoginResponseDTO {
  user: {
    id: string;
    email: string;
  };
  profile: ProfileDTO;
}

/**
 * Response DTO for logout
 */
export interface LogoutResponseDTO {
  message: string;
}

/**
 * Response DTO for GET /api/auth/session
 * Returns current user session information
 */
export interface GetSessionResponseDTO {
  user: {
    id: string;
    email: string;
  };
  profile: ProfileDTO;
}

// ============================================================================
// Error Response DTOs
// ============================================================================

/**
 * Standard error response structure for all API endpoints
 */
export interface ApiErrorResponse {
  error: {
    code: string;
    message: string;
    details?: Record<string, string>;
  };
}

/**
 * Common error codes used across the API
 */
export type ApiErrorCode =
  | 'UNAUTHORIZED'
  | 'FORBIDDEN'
  | 'NOT_FOUND'
  | 'VALIDATION_ERROR'
  | 'CONFLICT'
  | 'RATE_LIMIT_EXCEEDED'
  | 'INTERNAL_SERVER_ERROR';

// ============================================================================
// Helper Types
// ============================================================================

/**
 * Extract user ID from authenticated request context
 */
export type AuthenticatedUserId = string;

/**
 * Sort order types used across multiple endpoints
 */
export type SortOrder = 'asc' | 'desc';

/**
 * Common success message response
 */
export interface SuccessMessageResponse {
  message: string;
}



================================================
FILE: src/components/Welcome.astro
================================================
<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w 10xDevs Astro Starter!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt został zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentów interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczęcia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>
  </div>
</div>



================================================
FILE: src/components/article-detail/article-detail.types.ts
================================================
/**
 * Type definitions for Article Detail View
 * Includes ViewModels, component props, and utility functions
 */

import type { DifficultyLevel, ApiErrorResponse } from "../../types";

// ============================================================================
// View Models
// ============================================================================

/**
 * Article detail view model - top-level VM for the detail view
 */
export interface ArticleDetailVM {
  id: string;
  header: ArticleHeaderVM;
  sections: ArticleSectionsVM;
  completion?: ArticleCompletionVM; // Only present when authenticated
}

/**
 * Article header view model - contains formatted metadata for display
 */
export interface ArticleHeaderVM {
  title: string;
  levelLabel: string; // e.g., "Beginner"
  difficultyLabel: string; // e.g., "Difficulty 3/5"
  createdAtLabel: string; // Localized date
}

/**
 * Article sections view model - contains article content sections
 */
export interface ArticleSectionsVM {
  summary: string;
  content: string;
  keyTakeaways: string;
}

/**
 * Article completion view model - tracks user completion status
 */
export interface ArticleCompletionVM {
  isCompleted: boolean;
  completedAt: string | null;
}

/**
 * Article detail error view model - describes fetch errors
 */
export interface ArticleDetailErrorVM {
  kind: "http" | "network";
  status?: number;
  message: string;
  api?: ApiErrorResponse;
}

/**
 * Completion CTA state view model - tracks CTA component state
 */
export interface CompletionCTAStateVM {
  isSubmitting: boolean;
  error: string | null;
}

// ============================================================================
// Component Props
// ============================================================================

/**
 * Props for ArticleDetailView component
 */
export interface ArticleDetailViewProps {
  articleId: string;
  isAuthenticated: boolean;
  userSelectedLevel?: DifficultyLevel;
}

/**
 * Props for ContentHeader component
 */
export interface ContentHeaderProps {
  header: ArticleHeaderVM;
  headingId?: string;
}

/**
 * Props for ContentSections component
 */
export interface ContentSectionsProps {
  sections: ArticleSectionsVM;
}

/**
 * Props for CompletionCallToAction component
 */
export interface CompletionCallToActionProps {
  articleId: string;
  isCompleted: boolean;
  completedAt: string | null;
  onCompleted: (completedAt: string) => void;
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * UUID validation regex
 * Matches standard UUID v4 format
 */
const UUID_REGEX =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

/**
 * Validates if a string is a valid UUID
 */
export function isUuid(value: string): boolean {
  return UUID_REGEX.test(value);
}

/**
 * Formats difficulty level enum to display label
 */
export function formatLevel(level: string): string {
  const levelMap: Record<string, string> = {
    BEGINNER: "Beginner",
    INTERMEDIATE: "Intermediate",
    EXPERIENCED: "Experienced",
  };
  return levelMap[level] || level;
}

/**
 * Formats difficulty weight to display label
 */
export function formatDifficultyLabel(weight: number): string {
  return `Difficulty ${weight}/5`;
}

/**
 * Formats ISO date string to localized date label
 */
export function formatCreatedAtLabel(isoDate: string): string {
  try {
    const date = new Date(isoDate);
    return date.toLocaleDateString(undefined, {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  } catch {
    return isoDate;
  }
}



================================================
FILE: src/components/article-detail/ArticleDetailSkeleton.tsx
================================================
/**
 * ArticleDetailSkeleton - Loading skeleton for article detail page
 * Shows placeholder content while article data is being fetched
 */

export function ArticleDetailSkeleton() {
  return (
    <div
      className="animate-pulse space-y-8"
      role="status"
      aria-label="Loading article"
      aria-busy="true"
      aria-live="polite"
    >
      {/* Header skeleton */}
      <div className="space-y-4">
        {/* Badge skeleton */}
        <div className="h-6 w-20 rounded-full bg-muted" />
        
        {/* Title skeleton */}
        <div className="h-10 w-3/4 rounded bg-muted" />
        
        {/* Metadata row skeleton */}
        <div className="flex items-center gap-3">
          <div className="h-4 w-20 rounded bg-muted" />
          <div className="h-4 w-24 rounded bg-muted" />
          <div className="h-4 w-28 rounded bg-muted" />
        </div>
      </div>

      {/* Content sections skeleton - 3 sections for articles */}
      <div className="space-y-8">
        {/* Section 1: Summary */}
        <div className="space-y-3">
          <div className="h-7 w-28 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-3/4 rounded bg-muted" />
        </div>

        {/* Section 2: Content */}
        <div className="space-y-3">
          <div className="h-7 w-24 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-5/6 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-4/5 rounded bg-muted" />
        </div>

        {/* Section 3: Key Takeaways */}
        <div className="space-y-3">
          <div className="h-7 w-36 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-2/3 rounded bg-muted" />
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/article-detail/ArticleDetailView.tsx
================================================
/**
 * ArticleDetailView - Top-level client component for article detail page
 * Handles data fetching, loading/error/success states, and orchestrates child components
 */

import { useId, useCallback, useState } from "react";
import { useArticleDetail } from "./useArticleDetail";
import { ArticleDetailSkeleton } from "./ArticleDetailSkeleton";
import { NotFoundState } from "../shared/NotFoundState";
import { FullPageError } from "../shared/FullPageError";
import { ContentHeader } from "./ContentHeader";
import { ContentSections } from "./ContentSections";
import { CompletionCallToAction } from "./CompletionCallToAction";
import type { ArticleDetailViewProps } from "./article-detail.types";

export function ArticleDetailView({
  articleId,
  isAuthenticated,
  userSelectedLevel,
}: ArticleDetailViewProps) {
  const headingId = useId();
  
  // Fetch article detail
  const { data, isLoading, error, isNotFound, retry } = useArticleDetail({
    articleId,
    isAuthenticated,
  });

  // Local completion state for optimistic updates
  const [localCompletion, setLocalCompletion] = useState<{
    isCompleted: boolean;
    completedAt: string | null;
  } | null>(null);

  /**
   * Handle completion callback from CTA
   * Updates local state immediately for optimistic UI
   */
  const handleCompleted = useCallback((completedAt: string) => {
    setLocalCompletion({
      isCompleted: true,
      completedAt,
    });
  }, []);

  // Determine current completion state (local override takes precedence)
  const currentCompletion = localCompletion ?? data?.completion;

  // Loading state
  if (isLoading) {
    return (
      <section aria-labelledby={headingId} aria-busy="true">
        <ArticleDetailSkeleton />
      </section>
    );
  }

  // Not found state (404 or invalid UUID)
  if (isNotFound) {
    return (
      <section aria-labelledby={headingId}>
        <NotFoundState
          title="Article not found"
          description="The article you're looking for doesn't exist or may have been removed."
          backHref="/learning"
          backLabel="Back to Learning"
        />
      </section>
    );
  }

  // Error state (500, network, etc.)
  if (error) {
    const errorMessage =
      error.kind === "network"
        ? "Couldn't load article. Check your connection."
        : error.message || "Something went wrong while loading the article.";

    return (
      <section aria-labelledby={headingId}>
        <FullPageError message={errorMessage} onRetry={retry} />
      </section>
    );
  }

  // Guard: data should exist at this point
  if (!data) {
    return (
      <section aria-labelledby={headingId}>
        <FullPageError
          message="Article data is missing."
          onRetry={retry}
        />
      </section>
    );
  }

  // Success state - render article
  return (
    <section aria-labelledby={headingId}>
      <article className="space-y-8">
        {/* Header: Badge, Title, Metadata */}
        <ContentHeader header={data.header} headingId={headingId} />

        {/* Content Sections */}
        <ContentSections sections={data.sections} />

        {/* Completion CTA (authenticated users only) */}
        {isAuthenticated && currentCompletion && (
          <CompletionCallToAction
            articleId={articleId}
            isCompleted={currentCompletion.isCompleted}
            completedAt={currentCompletion.completedAt}
            onCompleted={handleCompleted}
          />
        )}
      </article>
    </section>
  );
}



================================================
FILE: src/components/article-detail/CompletionCallToAction.tsx
================================================
/**
 * CompletionCallToAction - Interactive CTA for marking article as read
 * Authenticated-only component with idempotent behavior
 * Shows completion status and allows one-time marking as read
 */

import { useState, useCallback } from "react";
import { toast } from "sonner";
import { Button } from "../ui/button";
import type {
  CompletionCallToActionProps,
  CompletionCTAStateVM,
} from "./article-detail.types";
import type { CompleteArticleResponseDTO, ApiErrorResponse } from "../../types";

export function CompletionCallToAction({
  articleId,
  isCompleted,
  completedAt,
  onCompleted,
}: CompletionCallToActionProps) {
  // Local state for submission
  const [state, setState] = useState<CompletionCTAStateVM>({
    isSubmitting: false,
    error: null,
  });

  /**
   * Format completion date for display
   */
  const formatCompletedDate = (isoDate: string): string => {
    const date = new Date(isoDate);
    return date.toLocaleDateString(undefined, {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  /**
   * Handle mark as read action
   */
  const handleMarkRead = useCallback(async () => {
    // Guard: Already completed
    if (isCompleted) {
      return;
    }

    setState({ isSubmitting: true, error: null });

    try {
      const response = await fetch(`/api/articles/${articleId}/complete`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      // Handle non-OK responses
      if (!response.ok) {
        // 401 Unauthorized - redirect to login
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }

        // 404 Not Found - article no longer exists
        if (response.status === 404) {
          setState({
            isSubmitting: false,
            error: "This article no longer exists.",
          });
          return;
        }

        // 429 Rate Limit or 500 Server Error - show toast and keep button enabled
        if (response.status === 429 || response.status >= 500) {
          const errorMessage =
            response.status === 429
              ? "Too many requests. Please try again in a moment."
              : "Something went wrong. Please try again.";

          setState({
            isSubmitting: false,
            error: errorMessage,
          });

          // Show toast for transient errors
          toast.error(errorMessage);
          return;
        }

        // Other errors - parse API response
        try {
          const errorData = (await response.json()) as ApiErrorResponse;
          setState({
            isSubmitting: false,
            error: errorData.error.message,
          });
        } catch {
          setState({
            isSubmitting: false,
            error: "An unexpected error occurred.",
          });
        }
        return;
      }

      // Success - parse response
      const data = (await response.json()) as CompleteArticleResponseDTO;

      // Update parent state via callback
      onCompleted(data.completed_at);

      // Clear local error state
      setState({ isSubmitting: false, error: null });

      // Show success toast
      toast.success("Marked as read");
    } catch (err) {
      // Network error
      const errorMessage = "Network error. Please check your connection.";
      setState({
        isSubmitting: false,
        error: errorMessage,
      });
      toast.error(errorMessage);
    }
  }, [articleId, isCompleted, onCompleted]);

  return (
    <section
      aria-label="Completion"
      className="mt-8 space-y-4 rounded-lg border border-border bg-card p-6"
    >
      {/* Status callout */}
      {isCompleted ? (
        // Completed state
        <div className="flex items-center gap-2 text-green-600 dark:text-green-400">
          <svg
            className="h-5 w-5"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M5 13l4 4L19 7"
            />
          </svg>
          <div>
            <p className="font-semibold">Read</p>
            {completedAt && (
              <p className="text-sm text-muted-foreground">
                Completed on {formatCompletedDate(completedAt)}
              </p>
            )}
          </div>
        </div>
      ) : (
        // Not completed state
        <div className="space-y-2">
          <p className="text-sm text-foreground">
            Finished reading? Mark this article as read to track your progress.
          </p>
        </div>
      )}

      {/* Primary action button */}
      <div className="space-y-3">
        <Button
          onClick={handleMarkRead}
          disabled={state.isSubmitting || isCompleted}
          className="w-full sm:w-auto"
          aria-label={isCompleted ? "Already marked as read" : "Mark as read"}
        >
          {state.isSubmitting
            ? "Marking..."
            : isCompleted
              ? "Read"
              : "Mark as read"}
        </Button>

        {/* Inline error message */}
        {state.error && (
          <div
            role="alert"
            className="rounded-md border border-destructive/20 bg-destructive/10 px-4 py-3 text-sm text-destructive"
          >
            {state.error}
          </div>
        )}
      </div>
    </section>
  );
}



================================================
FILE: src/components/article-detail/ContentHeader.tsx
================================================
/**
 * ContentHeader - Article header with type badge, title, and metadata
 * Displays article identity and key metadata in a structured format
 */

import type { ContentHeaderProps } from "./article-detail.types";

export function ContentHeader({ header, headingId }: ContentHeaderProps) {
  return (
    <header className="space-y-4">
      {/* Type badge */}
      <div>
        <span className="inline-flex items-center rounded-full bg-green-100 px-3 py-1 text-sm font-medium text-green-800 dark:bg-green-900 dark:text-green-200">
          Article
        </span>
      </div>

      {/* Title */}
      <h1 id={headingId} className="text-3xl font-bold text-foreground sm:text-4xl">
        {header.title}
      </h1>

      {/* Metadata row */}
      <dl className="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-muted-foreground">
        {/* Level */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Level</dt>
          <dd className="font-medium">{header.levelLabel}</dd>
        </div>

        <span aria-hidden="true">•</span>

        {/* Difficulty */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Difficulty</dt>
          <dd>{header.difficultyLabel}</dd>
        </div>

        <span aria-hidden="true">•</span>

        {/* Created date */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Published</dt>
          <dd>
            <time dateTime={header.createdAtLabel}>{header.createdAtLabel}</time>
          </dd>
        </div>
      </dl>
    </header>
  );
}



================================================
FILE: src/components/article-detail/ContentSections.tsx
================================================
/**
 * ContentSections - Structured article content sections
 * Renders all article sections in the required order:
 * 1. Summary
 * 2. Content
 * 3. Key Takeaways
 */

import { useId } from "react";
import type { ContentSectionsProps } from "./article-detail.types";

export function ContentSections({ sections }: ContentSectionsProps) {
  const summaryId = useId();
  const contentId = useId();
  const takeawaysId = useId();

  return (
    <div className="space-y-8">
      {/* Section 1: Summary */}
      <section aria-labelledby={summaryId} className="space-y-3">
        <h2 id={summaryId} className="text-2xl font-semibold text-foreground">
          Summary
        </h2>
        <p className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
          {sections.summary}
        </p>
      </section>

      {/* Section 2: Content */}
      <section aria-labelledby={contentId} className="space-y-3">
        <h2 id={contentId} className="text-2xl font-semibold text-foreground">
          Content
        </h2>
        <div className="prose prose-sm max-w-none dark:prose-invert">
          <p className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
            {sections.content}
          </p>
        </div>
      </section>

      {/* Section 3: Key Takeaways */}
      <section
        aria-labelledby={takeawaysId}
        className="space-y-3 rounded-lg border border-primary/20 bg-primary/5 p-6"
      >
        <h2 id={takeawaysId} className="text-2xl font-semibold text-foreground">
          Key Takeaways
        </h2>
        <div className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
          {sections.keyTakeaways}
        </div>
      </section>
    </div>
  );
}



================================================
FILE: src/components/article-detail/useArticleDetail.ts
================================================
/**
 * Custom hook for fetching and managing article detail data
 * Handles loading states, errors, UUID validation, and DTO-to-VM mapping
 */

import { useState, useEffect, useCallback, useRef } from "react";
import type {
  GetArticleDetailResponseDTO,
  ApiErrorResponse,
} from "../../types";
import type {
  ArticleDetailVM,
  ArticleDetailErrorVM,
  ArticleHeaderVM,
  ArticleSectionsVM,
  ArticleCompletionVM,
} from "./article-detail.types";
import {
  isUuid,
  formatLevel,
  formatDifficultyLabel,
  formatCreatedAtLabel,
} from "./article-detail.types";

interface UseArticleDetailOptions {
  articleId: string;
  isAuthenticated: boolean;
}

interface UseArticleDetailReturn {
  data: ArticleDetailVM | null;
  isLoading: boolean;
  error: ArticleDetailErrorVM | null;
  isNotFound: boolean;
  retry: () => void;
}

/**
 * Parse API error response
 */
async function parseApiError(response: Response): Promise<ArticleDetailErrorVM> {
  try {
    const data = (await response.json()) as ApiErrorResponse;
    return {
      kind: "http",
      status: response.status,
      message: data.error.message,
      api: data,
    };
  } catch {
    return {
      kind: "http",
      status: response.status,
      message: `Request failed with status ${response.status}`,
    };
  }
}

/**
 * Map article DTO to view model
 */
function mapDtoToVM(
  dto: GetArticleDetailResponseDTO,
  isAuthenticated: boolean
): ArticleDetailVM {
  // Map header
  const header: ArticleHeaderVM = {
    title: dto.title,
    levelLabel: formatLevel(dto.level),
    difficultyLabel: formatDifficultyLabel(dto.difficulty_weight),
    createdAtLabel: formatCreatedAtLabel(dto.created_at),
  };

  // Map sections
  const sections: ArticleSectionsVM = {
    summary: dto.summary,
    content: dto.content,
    keyTakeaways: dto.key_takeaways,
  };

  // Map completion (only for authenticated users)
  let completion: ArticleCompletionVM | undefined = undefined;
  if (isAuthenticated) {
    completion = {
      isCompleted: dto.is_completed,
      completedAt: dto.completed_at,
    };
  }

  return {
    id: dto.id,
    header,
    sections,
    completion,
  };
}

/**
 * Custom hook for fetching article detail
 */
export function useArticleDetail(
  options: UseArticleDetailOptions
): UseArticleDetailReturn {
  const { articleId, isAuthenticated } = options;

  // Data state
  const [data, setData] = useState<ArticleDetailVM | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<ArticleDetailErrorVM | null>(null);
  const [isNotFound, setIsNotFound] = useState(false);

  // Abort controller for cleanup
  const abortControllerRef = useRef<AbortController | null>(null);

  /**
   * Fetch article detail from API
   */
  const fetchDetail = useCallback(async () => {
    // Pre-validate UUID to avoid unnecessary API call
    if (!isUuid(articleId)) {
      setIsLoading(false);
      setIsNotFound(true);
      setError(null);
      setData(null);
      return;
    }

    // Cancel any in-flight request
    abortControllerRef.current?.abort();

    // Create new abort controller
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setIsLoading(true);
    setError(null);
    setIsNotFound(false);

    try {
      const response = await fetch(`/api/articles/${articleId}`, {
        signal: abortController.signal,
      });

      if (!response.ok) {
        // Handle 404 or 400 (invalid UUID) as not found
        if (response.status === 404 || response.status === 400) {
          setIsNotFound(true);
          setData(null);
          setError(null);
        } else {
          // Handle other errors (500, network, etc.)
          const errorData = await parseApiError(response);
          setError(errorData);
          setData(null);
          setIsNotFound(false);
        }
        return;
      }

      // Success - parse and map to VM
      const dto = (await response.json()) as GetArticleDetailResponseDTO;
      const vm = mapDtoToVM(dto, isAuthenticated);

      setData(vm);
      setError(null);
      setIsNotFound(false);
    } catch (err) {
      // Handle abort and network errors
      if (err instanceof Error && err.name === "AbortError") {
        // Request was cancelled, ignore
        return;
      }

      // Network error
      setError({
        kind: "network",
        message: "Couldn't load article. Check your connection.",
      });
      setData(null);
      setIsNotFound(false);
    } finally {
      setIsLoading(false);
    }
  }, [articleId, isAuthenticated]);

  /**
   * Retry fetching data
   */
  const retry = useCallback(() => {
    fetchDetail();
  }, [fetchDetail]);

  /**
   * Fetch data on mount and when dependencies change
   */
  useEffect(() => {
    fetchDetail();

    // Cleanup on unmount
    return () => {
      abortControllerRef.current?.abort();
    };
  }, [fetchDetail]);

  return {
    data,
    isLoading,
    error,
    isNotFound,
    retry,
  };
}



================================================
FILE: src/components/auth/AuthFormLogin.tsx
================================================
import * as React from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { InlineFieldError } from "./InlineFieldError"
import type { ApiErrorResponse } from "@/types"

interface LoginFormData {
  identifier: string
  password: string
}

interface LoginFormErrors {
  identifier?: string
  password?: string
  general?: string
}

/**
 * Login form component with client-side validation
 * Submits to POST /api/auth/login and handles errors
 * Links to /signup for new users
 */
export function AuthFormLogin() {
  const [formData, setFormData] = React.useState<LoginFormData>({
    identifier: "",
    password: "",
  })
  const [errors, setErrors] = React.useState<LoginFormErrors>({})
  const [isSubmitting, setIsSubmitting] = React.useState(false)

  // Client-side validation
  const validateForm = (): boolean => {
    const newErrors: LoginFormErrors = {}

    if (!formData.identifier.trim()) {
      newErrors.identifier = "Email or username is required."
    }

    if (!formData.password) {
      newErrors.password = "Password is required."
    }

    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    // Clear previous errors
    setErrors({})

    // Validate
    if (!validateForm()) {
      return
    }

    setIsSubmitting(true)

    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          identifier: formData.identifier.trim(),
          password: formData.password,
        }),
      })

      if (!response.ok) {
        const errorData: ApiErrorResponse = await response.json()

        if (response.status === 401) {
          // Generic invalid credentials error
          setErrors({ general: errorData.error.message })
        } else if (response.status === 400 && errorData.error.details) {
          // Field-specific validation errors
          setErrors(errorData.error.details as LoginFormErrors)
        } else {
          // Other errors
          setErrors({ general: errorData.error.message })
        }
        return
      }

      // Success - redirect to home
      window.location.href = "/"
    } catch (error) {
      setErrors({
        general: "An unexpected error occurred. Please try again.",
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleInputChange = (field: keyof LoginFormData, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }))
    // Clear field error when user starts typing
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: undefined }))
    }
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="space-y-1">
        <CardTitle className="text-2xl">Log in</CardTitle>
        <CardDescription>
          Enter your email or username and password to access your account
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4" noValidate>
          {/* General error message */}
          {errors.general && (
            <div
              className="p-3 rounded-md bg-destructive/10 border border-destructive/20 text-sm text-destructive"
              role="alert"
              aria-live="polite"
            >
              {errors.general}
            </div>
          )}

          {/* Email or Username field */}
          <div className="space-y-2">
            <Label htmlFor="identifier">Email or Username</Label>
            <Input
              id="identifier"
              name="identifier"
              type="text"
              autoComplete="username"
              placeholder="you@example.com or username"
              value={formData.identifier}
              onChange={(e) => handleInputChange("identifier", e.target.value)}
              disabled={isSubmitting}
              aria-invalid={!!errors.identifier}
              aria-describedby={
                errors.identifier ? "identifier-error" : undefined
              }
            />
            {errors.identifier && (
              <InlineFieldError
                error={errors.identifier}
                aria-id="identifier-error"
              />
            )}
          </div>

          {/* Password field */}
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              name="password"
              type="password"
              autoComplete="current-password"
              placeholder="Enter your password"
              value={formData.password}
              onChange={(e) => handleInputChange("password", e.target.value)}
              disabled={isSubmitting}
              aria-invalid={!!errors.password}
              aria-describedby={errors.password ? "password-error" : undefined}
            />
            {errors.password && (
              <InlineFieldError error={errors.password} aria-id="password-error" />
            )}
          </div>

          {/* Submit button */}
          <Button
            type="submit"
            className="w-full"
            disabled={isSubmitting}
            aria-busy={isSubmitting}
          >
            {isSubmitting ? "Logging in..." : "Log in"}
          </Button>

          {/* Link to signup */}
          <div className="text-center text-sm text-muted-foreground">
            Don't have an account?{" "}
            <a
              href="/signup"
              className="text-primary hover:underline focus:outline-none focus:underline"
            >
              Sign up
            </a>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}



================================================
FILE: src/components/auth/AuthFormSignup.tsx
================================================
import * as React from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { InlineFieldError } from "./InlineFieldError"
import { LevelSelector } from "./LevelSelector"
import type { ApiErrorResponse, DifficultyLevel } from "@/types"

interface SignupFormData {
  email: string
  username: string
  password: string
  selected_level: DifficultyLevel | null
}

interface SignupFormErrors {
  email?: string
  username?: string
  password?: string
  selected_level?: string
  general?: string
}

/**
 * Signup form component with client-side validation
 * Submits to POST /api/auth/signup and handles errors
 * Includes email, username, password, and level selector
 * Links to /login for existing users
 */
export function AuthFormSignup() {
  const [formData, setFormData] = React.useState<SignupFormData>({
    email: "",
    username: "",
    password: "",
    selected_level: null,
  })
  const [errors, setErrors] = React.useState<SignupFormErrors>({})
  const [isSubmitting, setIsSubmitting] = React.useState(false)

  // Client-side validation
  const validateForm = (): boolean => {
    const newErrors: SignupFormErrors = {}

    // Email validation
    if (!formData.email.trim()) {
      newErrors.email = "Email is required."
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = "Enter a valid email address."
    }

    // Username validation
    if (!formData.username.trim()) {
      newErrors.username = "Username is required."
    } else if (formData.username.trim().length < 3) {
      newErrors.username = "Username must be at least 3 characters."
    } else if (formData.username.trim().length > 20) {
      newErrors.username = "Username must be at most 20 characters."
    } else if (!/^[a-zA-Z0-9_]+$/.test(formData.username)) {
      newErrors.username =
        "Username can only contain letters, numbers, and underscores."
    }

    // Password validation
    if (!formData.password) {
      newErrors.password = "Password is required."
    } else if (formData.password.length < 8) {
      newErrors.password = "Password must be at least 8 characters."
    }

    // Level validation
    if (!formData.selected_level) {
      newErrors.selected_level = "Select a starting level."
    }

    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    // Clear previous errors
    setErrors({})

    // Validate
    if (!validateForm()) {
      return
    }

    setIsSubmitting(true)

    try {
      const response = await fetch("/api/auth/signup", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: formData.email.trim(),
          username: formData.username.trim(),
          password: formData.password,
          selected_level: formData.selected_level,
        }),
      })

      if (!response.ok) {
        const errorData: ApiErrorResponse = await response.json()

        if (response.status === 409) {
          // Conflict - duplicate email or username
          // Server should provide field-specific error in details
          if (errorData.error.details) {
            setErrors(errorData.error.details as SignupFormErrors)
          } else {
            setErrors({ general: errorData.error.message })
          }
        } else if (response.status === 400 && errorData.error.details) {
          // Field-specific validation errors
          setErrors(errorData.error.details as SignupFormErrors)
        } else {
          // Other errors
          setErrors({ general: errorData.error.message })
        }
        return
      }

      // Success - redirect to home
      window.location.href = "/"
    } catch (error) {
      setErrors({
        general: "An unexpected error occurred. Please try again.",
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleInputChange = (
    field: keyof SignupFormData,
    value: string | DifficultyLevel
  ) => {
    setFormData((prev) => ({ ...prev, [field]: value }))
    // Clear field error when user starts typing
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: undefined }))
    }
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="space-y-1">
        <CardTitle className="text-2xl">Create an account</CardTitle>
        <CardDescription>
          Enter your information to get started with Cook Mastery
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4" noValidate>
          {/* General error message */}
          {errors.general && (
            <div
              className="p-3 rounded-md bg-destructive/10 border border-destructive/20 text-sm text-destructive"
              role="alert"
              aria-live="polite"
            >
              {errors.general}
            </div>
          )}

          {/* Email field */}
          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              placeholder="you@example.com"
              value={formData.email}
              onChange={(e) => handleInputChange("email", e.target.value)}
              disabled={isSubmitting}
              aria-invalid={!!errors.email}
              aria-describedby={errors.email ? "email-error" : undefined}
            />
            {errors.email && (
              <InlineFieldError error={errors.email} aria-id="email-error" />
            )}
          </div>

          {/* Username field */}
          <div className="space-y-2">
            <Label htmlFor="username">Username</Label>
            <Input
              id="username"
              name="username"
              type="text"
              autoComplete="username"
              placeholder="your_username"
              value={formData.username}
              onChange={(e) => handleInputChange("username", e.target.value)}
              disabled={isSubmitting}
              aria-invalid={!!errors.username}
              aria-describedby={errors.username ? "username-error" : undefined}
            />
            {errors.username && (
              <InlineFieldError
                error={errors.username}
                aria-id="username-error"
              />
            )}
          </div>

          {/* Password field */}
          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              name="password"
              type="password"
              autoComplete="new-password"
              placeholder="At least 8 characters"
              value={formData.password}
              onChange={(e) => handleInputChange("password", e.target.value)}
              disabled={isSubmitting}
              aria-invalid={!!errors.password}
              aria-describedby={errors.password ? "password-error" : undefined}
            />
            {errors.password && (
              <InlineFieldError
                error={errors.password}
                aria-id="password-error"
              />
            )}
          </div>

          {/* Level selector */}
          <div className="space-y-2">
            <LevelSelector
              value={formData.selected_level}
              onChange={(level) => handleInputChange("selected_level", level)}
              error={errors.selected_level}
              disabled={isSubmitting}
            />
            {errors.selected_level && (
              <InlineFieldError error={errors.selected_level} />
            )}
          </div>

          {/* Submit button */}
          <Button
            type="submit"
            className="w-full"
            disabled={isSubmitting}
            aria-busy={isSubmitting}
          >
            {isSubmitting ? "Creating account..." : "Create account"}
          </Button>

          {/* Link to login */}
          <div className="text-center text-sm text-muted-foreground">
            Already have an account?{" "}
            <a
              href="/login"
              className="text-primary hover:underline focus:outline-none focus:underline"
            >
              Log in
            </a>
          </div>
        </form>
      </CardContent>
    </Card>
  )
}



================================================
FILE: src/components/auth/InlineFieldError.tsx
================================================
import * as React from "react"
import { cn } from "@/lib/utils"

interface InlineFieldErrorProps {
  error?: string
  className?: string
}

/**
 * Displays inline validation error messages for form fields
 * Used to render ApiErrorResponse.error.details[field] when present
 */
export function InlineFieldError({ error, className }: InlineFieldErrorProps) {
  if (!error) return null

  return (
    <p
      className={cn("text-sm text-destructive mt-1.5", className)}
      role="alert"
      aria-live="polite"
    >
      {error}
    </p>
  )
}



================================================
FILE: src/components/auth/LevelSelector.tsx
================================================
import * as React from "react"
import { Label } from "@/components/ui/label"
import { cn } from "@/lib/utils"
import type { DifficultyLevel } from "@/types"

interface LevelOption {
  value: DifficultyLevel
  label: string
  description: string
}

const levelOptions: LevelOption[] = [
  {
    value: "BEGINNER",
    label: "Beginner",
    description: "Just getting started in the kitchen",
  },
  {
    value: "INTERMEDIATE",
    label: "Intermediate",
    description: "Comfortable with basic techniques",
  },
  {
    value: "EXPERIENCED",
    label: "Experienced",
    description: "Confident with advanced cooking",
  },
]

interface LevelSelectorProps {
  value: DifficultyLevel | null
  onChange: (level: DifficultyLevel) => void
  error?: string
  disabled?: boolean
}

/**
 * Single-select difficulty level selector for signup
 * Implements accessible radio group pattern
 */
export function LevelSelector({
  value,
  onChange,
  error,
  disabled = false,
}: LevelSelectorProps) {
  const groupId = React.useId()

  return (
    <div className="space-y-3">
      <Label htmlFor={groupId} className="text-base">
        What's your skill level?
      </Label>
      <div
        role="radiogroup"
        aria-labelledby={groupId}
        aria-invalid={!!error}
        className="space-y-2"
      >
        {levelOptions.map((option) => {
          const isSelected = value === option.value
          const radioId = `${groupId}-${option.value}`

          return (
            <label
              key={option.value}
              htmlFor={radioId}
              className={cn(
                "flex items-start gap-3 p-4 rounded-lg border cursor-pointer transition-all",
                "hover:bg-accent/50",
                isSelected &&
                  "border-primary bg-primary/5 ring-2 ring-primary/20",
                !isSelected && "border-border",
                disabled && "opacity-50 cursor-not-allowed",
                error && !isSelected && "border-destructive"
              )}
            >
              <input
                type="radio"
                id={radioId}
                name="selected_level"
                value={option.value}
                checked={isSelected}
                onChange={() => onChange(option.value)}
                disabled={disabled}
                className="mt-0.5 h-4 w-4 text-primary focus:ring-2 focus:ring-primary/20"
                aria-describedby={`${radioId}-description`}
              />
              <div className="flex-1 space-y-1">
                <div className="font-medium text-sm">{option.label}</div>
                <div
                  id={`${radioId}-description`}
                  className="text-sm text-muted-foreground"
                >
                  {option.description}
                </div>
              </div>
            </label>
          )
        })}
      </div>
    </div>
  )
}



================================================
FILE: src/components/content/content.types.ts
================================================
/**
 * Shared content types for ContentCard component
 * Decouples card rendering from view-specific types (Home, Learning, etc.)
 */

import type { DifficultyLevel, TutorialCategory } from "../../types";

/**
 * Content type discriminator for cards
 */
export type ContentCardItemType = "tutorial" | "article";

/**
 * Shared view model for content cards
 * Used by Home, Learning, and other views that display content items
 */
export interface ContentCardItemVM {
  type: ContentCardItemType;
  id: string;
  title: string;
  summary: string;
  level: DifficultyLevel;
  difficultyWeight: number;
  createdAt: string;
  href: string;

  category?: TutorialCategory; // tutorial-only
  isNew: boolean;

  // completion (optional; only include when authenticated + include_completed=true)
  isCompleted?: boolean;
  completedAt?: string | null;
}



================================================
FILE: src/components/content/ContentCard.tsx
================================================
/**
 * ContentCard - Unified card component for tutorials and articles
 * Displays content with type badge, title, summary, metadata, and optional completion status
 */

import type { ContentCardItemVM } from "./content.types";
import { NewBadge } from "./NewBadge";

interface ContentCardProps {
  item: ContentCardItemVM;
}

/**
 * Format difficulty level for display
 */
function formatLevel(level: string): string {
  return level.charAt(0) + level.slice(1).toLowerCase();
}

/**
 * Format tutorial category for display
 */
function formatCategory(category: string): string {
  return category.charAt(0) + category.slice(1).toLowerCase();
}

export function ContentCard({ item }: ContentCardProps) {
  const typeBadge = item.type === "tutorial" ? "Tutorial" : "Article";
  const typeColor =
    item.type === "tutorial"
      ? "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
      : "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200";

  return (
    <li>
      <a
        href={item.href}
        className="group block rounded-lg border bg-card p-4 transition-colors hover:border-primary hover:bg-accent/50"
      >
        {/* Header: Type badge and New badge */}
        <div className="mb-3 flex items-center justify-between gap-2">
          <span
            className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${typeColor}`}
          >
            {typeBadge}
          </span>
          {item.isNew && <NewBadge />}
        </div>

        {/* Title */}
        <h3 className="mb-2 text-lg font-semibold text-foreground group-hover:text-primary">
          {item.title}
        </h3>

        {/* Summary */}
        <p className="mb-3 text-sm text-muted-foreground line-clamp-2">
          {item.summary}
        </p>

        {/* Metadata row */}
        <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
          <span className="font-medium">{formatLevel(item.level)}</span>
          <span aria-hidden="true">•</span>
          <span>Difficulty {item.difficultyWeight}/5</span>
          {item.category && (
            <>
              <span aria-hidden="true">•</span>
              <span>{formatCategory(item.category)}</span>
            </>
          )}
        </div>

        {/* Completion indicator (only for authenticated users) */}
        {item.isCompleted !== undefined && item.isCompleted && (
          <div className="mt-3 flex items-center gap-1 text-xs font-medium text-green-600 dark:text-green-400">
            <svg
              className="h-4 w-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M5 13l4 4L19 7"
              />
            </svg>
            <span>Completed</span>
          </div>
        )}
      </a>
    </li>
  );
}



================================================
FILE: src/components/content/NewBadge.tsx
================================================
/**
 * NewBadge - Displays "New" badge for recently created content
 * The parent component determines if the badge should be shown via conditional rendering
 */

export function NewBadge() {
  return (
    <span className="inline-flex items-center rounded-full bg-accent px-2 py-0.5 text-xs font-medium text-accent-foreground">
      New
    </span>
  );
}



================================================
FILE: src/components/cookbook/cookbook.types.ts
================================================
/**
 * View Model Types and Helpers for Cookbook Components
 *
 * This file contains all ViewModel types used by cookbook components,
 * as well as helper functions for data transformation and formatting.
 */

import type {
  CookbookEntryDTO,
  ListCookbookEntriesResponseDTO,
  ApiErrorResponse,
  PaginationMeta,
} from '@/types';

// ============================================================================
// Sort Types
// ============================================================================

export type CookbookSort = 'newest' | 'oldest' | 'title_asc';

// ============================================================================
// List View Models
// ============================================================================

/**
 * View model for a single cookbook entry in list view
 */
export interface CookbookEntryListItemVM {
  id: string;
  title: string;
  url: string;
  urlLabel: string;
  notesPreview?: string;
  createdAtLabel: string;
}

/**
 * Pagination view model for cookbook list
 */
export interface CookbookListPaginationVM {
  page: number;
  limit: number;
  totalItems: number;
  totalPages: number;
}

/**
 * Complete list view model
 */
export interface CookbookListVM {
  entries: CookbookEntryListItemVM[];
  pagination: CookbookListPaginationVM;
}

// ============================================================================
// Detail View Models
// ============================================================================

/**
 * View model for cookbook entry detail view
 */
export interface CookbookEntryDetailVM {
  id: string;
  title: string;
  url: string;
  notes: string;
  createdAtLabel: string;
  updatedAtLabel: string;
}

// ============================================================================
// Form View Models
// ============================================================================

/**
 * Form state for create/edit operations
 */
export interface CookbookEntryFormVM {
  url: string;
  title: string;
  notes: string;
}

/**
 * Form validation errors
 */
export interface CookbookEntryFormErrorsVM {
  url?: string;
  title?: string;
  notes?: string;
  general?: string;
}

// ============================================================================
// Edit State View Models
// ============================================================================

/**
 * Edit state tracking for detail view
 */
export interface CookbookEntryEditStateVM {
  mode: 'view' | 'edit';
  isSaving: boolean;
  isDeleting: boolean;
  isDirty: boolean;
}

// ============================================================================
// Error View Models
// ============================================================================

/**
 * Error view model for list operations
 */
export interface CookbookListErrorVM {
  kind: 'http' | 'network';
  status?: number;
  message: string;
  api?: ApiErrorResponse;
}

/**
 * Error view model for detail operations
 */
export interface CookbookEntryErrorVM {
  kind: 'http' | 'network';
  status?: number;
  message: string;
  api?: ApiErrorResponse;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Validates if a string is a valid UUID v4 format
 */
export function isUuid(value: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(value);
}

/**
 * Formats an ISO date string to a human-readable date label
 */
export function formatDateLabel(iso: string): string {
  try {
    const date = new Date(iso);
    return date.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  } catch {
    return 'Unknown date';
  }
}

/**
 * Creates a preview text from notes, truncating to maxLen characters
 * and normalizing whitespace
 */
export function makeNotesPreview(notes: string | null | undefined, maxLen = 140): string {
  if (!notes) return '';

  // Normalize whitespace: collapse multiple spaces/newlines into single space
  const normalized = notes.replace(/\s+/g, ' ').trim();

  if (normalized.length <= maxLen) {
    return normalized;
  }

  // Truncate and add ellipsis
  return normalized.slice(0, maxLen).trim() + '…';
}

/**
 * Extracts a display-friendly label from a URL (hostname)
 */
export function formatUrlLabel(url: string): string {
  try {
    const parsed = new URL(url);
    return parsed.hostname;
  } catch {
    // If URL parsing fails, return truncated version
    if (url.length > 50) {
      return url.slice(0, 47) + '...';
    }
    return url;
  }
}

/**
 * Validates if a string is a valid URL with http/https protocol
 */
export function isValidUrl(value: string): boolean {
  try {
    const url = new URL(value);
    return url.protocol === 'http:' || url.protocol === 'https:';
  } catch {
    return false;
  }
}

/**
 * Converts PaginationMeta DTO to PaginationVM
 */
export function toPaginationVM(meta: PaginationMeta): CookbookListPaginationVM {
  return {
    page: meta.page,
    limit: meta.limit,
    totalItems: meta.total_items,
    totalPages: meta.total_pages,
  };
}

/**
 * Converts CookbookEntryDTO to list item ViewModel
 */
export function toListItemVM(dto: CookbookEntryDTO): CookbookEntryListItemVM {
  return {
    id: dto.id,
    title: dto.title,
    url: dto.url,
    urlLabel: formatUrlLabel(dto.url),
    notesPreview: makeNotesPreview(dto.notes),
    createdAtLabel: formatDateLabel(dto.created_at),
  };
}

/**
 * Converts CookbookEntryDTO to detail ViewModel
 */
export function toDetailVM(dto: CookbookEntryDTO): CookbookEntryDetailVM {
  return {
    id: dto.id,
    title: dto.title,
    url: dto.url,
    notes: dto.notes ?? '',
    createdAtLabel: formatDateLabel(dto.created_at),
    updatedAtLabel: formatDateLabel(dto.updated_at),
  };
}

/**
 * Converts list response DTO to list ViewModel
 */
export function toListVM(dto: ListCookbookEntriesResponseDTO): CookbookListVM {
  return {
    entries: dto.entries.map(toListItemVM),
    pagination: toPaginationVM(dto.pagination),
  };
}

/**
 * Creates an initial empty form state
 */
export function createEmptyForm(): CookbookEntryFormVM {
  return {
    url: '',
    title: '',
    notes: '',
  };
}

/**
 * Creates form state from detail ViewModel
 */
export function createFormFromDetail(detail: CookbookEntryDetailVM): CookbookEntryFormVM {
  return {
    url: detail.url,
    title: detail.title,
    notes: detail.notes,
  };
}

/**
 * Checks if two form states are equal (for dirty checking)
 */
export function areFormsEqual(a: CookbookEntryFormVM, b: CookbookEntryFormVM): boolean {
  return a.url === b.url && a.title === b.title && a.notes === b.notes;
}



================================================
FILE: src/components/cookbook/CookbookCreateView.tsx
================================================
/**
 * CookbookCreateView - Page-level component for creating new cookbook entries
 * Manages form state and submission for POST /api/cookbook
 */

import { useState } from 'react';
import { toast } from 'sonner';
import CookbookEntryForm from './CookbookEntryForm';
import { createEmptyForm, isValidUrl } from './cookbook.types';
import type { CookbookEntryFormVM, CookbookEntryFormErrorsVM } from './cookbook.types';
import type { CreateCookbookEntryCommand, ApiErrorResponse } from '@/types';

interface CookbookCreateViewProps {
  isAuthenticated: boolean;
}

export default function CookbookCreateView({ isAuthenticated }: CookbookCreateViewProps) {
  const [form, setForm] = useState<CookbookEntryFormVM>(createEmptyForm());
  const [errors, setErrors] = useState<CookbookEntryFormErrorsVM>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  /**
   * Client-side validation before submission
   */
  const validateForm = (): boolean => {
    const newErrors: CookbookEntryFormErrorsVM = {};

    // URL validation
    if (!form.url.trim()) {
      newErrors.url = 'Recipe URL is required';
    } else if (!isValidUrl(form.url)) {
      newErrors.url = 'Please enter a valid URL starting with http:// or https://';
    }

    // Title validation
    if (!form.title.trim()) {
      newErrors.title = 'Title is required';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  /**
   * Handle form field changes
   */
  const handleChange = (next: Partial<CookbookEntryFormVM>) => {
    setForm((prev) => ({ ...prev, ...next }));

    // Clear field error on change
    if (next.url !== undefined && errors.url) {
      setErrors((prev) => ({ ...prev, url: undefined }));
    }
    if (next.title !== undefined && errors.title) {
      setErrors((prev) => ({ ...prev, title: undefined }));
    }
    if (next.notes !== undefined && errors.notes) {
      setErrors((prev) => ({ ...prev, notes: undefined }));
    }
  };

  /**
   * Handle form submission
   */
  const handleSubmit = async () => {
    // Client-side validation
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    setErrors({});

    try {
      // Build command (send notes as string or undefined, not null)
      const command: CreateCookbookEntryCommand = {
        url: form.url.trim(),
        title: form.title.trim(),
        notes: form.notes.trim() || undefined,
      };

      const response = await fetch('/api/cookbook', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(command),
      });

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      // Handle validation errors (400)
      if (response.status === 400) {
        const errorData = (await response.json()) as ApiErrorResponse;
        const newErrors: CookbookEntryFormErrorsVM = {};

        if (errorData.error.details) {
          if (errorData.error.details.url) {
            newErrors.url = errorData.error.details.url;
          }
          if (errorData.error.details.title) {
            newErrors.title = errorData.error.details.title;
          }
          if (errorData.error.details.notes) {
            newErrors.notes = errorData.error.details.notes;
          }
          if (errorData.error.details.general) {
            newErrors.general = errorData.error.details.general;
          }
        }

        if (Object.keys(newErrors).length > 0) {
          setErrors(newErrors);
        } else {
          setErrors({ general: errorData.error.message });
        }
        return;
      }

      // Handle other errors
      if (!response.ok) {
        const errorData = (await response.json()) as ApiErrorResponse;
        toast.error(errorData.error.message || 'Failed to save entry');
        return;
      }

      // Success
      const data = await response.json();
      toast.success('Cookbook entry saved');
      window.location.href = `/cookbook/${data.id}`;
    } catch (err) {
      // Network error
      toast.error("Couldn't save entry. Check your connection.");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <section className="w-full">
      <div className="mb-6">
        <div className="flex items-center gap-2">
          <a
            href="/cookbook"
            className="text-sm text-muted-foreground hover:text-foreground transition-colors"
          >
            ← Back to Cookbook
          </a>
        </div>
        <h2 className="mt-4 text-3xl font-bold tracking-tight">New cookbook entry</h2>
      </div>

      {/* Form */}
      <div className="rounded-lg border border-border bg-card p-6">
        <CookbookEntryForm
          value={form}
          errors={errors}
          disabled={isSubmitting}
          submitLabel={isSubmitting ? 'Saving...' : 'Save'}
          onChange={handleChange}
          onSubmit={handleSubmit}
        />
      </div>
    </section>
  );
}



================================================
FILE: src/components/cookbook/CookbookEntryCard.tsx
================================================
/**
 * CookbookEntryCard - Compact card for single cookbook entry in list view
 */

import { Card, CardContent, CardHeader } from '@/components/ui/card';
import type { CookbookEntryListItemVM } from './cookbook.types';

interface CookbookEntryCardProps {
  entry: CookbookEntryListItemVM;
}

export default function CookbookEntryCard({ entry }: CookbookEntryCardProps) {
  return (
    <li>
      <Card>
        <CardHeader className="pb-3">
          <div className="flex items-start justify-between gap-4">
            <a
              href={`/cookbook/${entry.id}`}
              className="flex-1 text-lg font-semibold leading-tight tracking-tight hover:underline"
            >
              {entry.title}
            </a>
          </div>
        </CardHeader>
        <CardContent className="space-y-2">
          {/* External URL */}
          <div className="flex items-center gap-2 text-sm">
            <a
              href={entry.url}
              target="_blank"
              rel="noopener noreferrer"
              className="text-muted-foreground hover:text-foreground transition-colors flex items-center gap-1"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
                className="h-4 w-4"
                aria-hidden="true"
              >
                <path d="M12.232 4.232a2.5 2.5 0 013.536 3.536l-1.225 1.224a.75.75 0 001.061 1.06l1.224-1.224a4 4 0 00-5.656-5.656l-3 3a4 4 0 00.225 5.865.75.75 0 00.977-1.138 2.5 2.5 0 01-.142-3.667l3-3z" />
                <path d="M11.603 7.963a.75.75 0 00-.977 1.138 2.5 2.5 0 01.142 3.667l-3 3a2.5 2.5 0 01-3.536-3.536l1.225-1.224a.75.75 0 00-1.061-1.06l-1.224 1.224a4 4 0 105.656 5.656l3-3a4 4 0 00-.225-5.865z" />
              </svg>
              {entry.urlLabel}
            </a>
          </div>

          {/* Notes preview */}
          {entry.notesPreview && (
            <p className="text-sm text-muted-foreground line-clamp-2">{entry.notesPreview}</p>
          )}

          {/* Created date */}
          <p className="text-xs text-muted-foreground">Added {entry.createdAtLabel}</p>
        </CardContent>
      </Card>
    </li>
  );
}



================================================
FILE: src/components/cookbook/CookbookEntryDetail.tsx
================================================
/**
 * CookbookEntryDetail - Presentational component for entry detail
 * Renders view mode (read-only) or edit mode (form)
 */

import CookbookEntryForm from './CookbookEntryForm';
import type {
  CookbookEntryDetailVM,
  CookbookEntryFormVM,
  CookbookEntryFormErrorsVM,
} from './cookbook.types';

interface CookbookEntryDetailProps {
  entry: CookbookEntryDetailVM;
  mode: 'view' | 'edit';
  form: CookbookEntryFormVM;
  errors: CookbookEntryFormErrorsVM;
  isSubmitting: boolean;
  onEdit: () => void;
  onCancel: () => void;
  onChange: (next: Partial<CookbookEntryFormVM>) => void;
  onSave: () => void;
  onDelete: () => void;
}

export default function CookbookEntryDetail({
  entry,
  mode,
  form,
  errors,
  isSubmitting,
  onEdit,
  onCancel,
  onChange,
  onSave,
  onDelete,
}: CookbookEntryDetailProps) {
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-start sm:justify-between">
        <div className="flex-1">
          <h2 className="text-3xl font-bold tracking-tight">{entry.title}</h2>
          <div className="mt-2 flex flex-wrap gap-x-4 gap-y-1 text-sm text-muted-foreground">
            <span>Created {entry.createdAtLabel}</span>
            <span>Updated {entry.updatedAtLabel}</span>
          </div>
        </div>
        <div className="flex gap-2">
          {mode === 'view' ? (
            <>
              <a
                href={entry.url}
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex h-9 items-center justify-center gap-1 rounded-md bg-primary px-3 text-sm font-medium text-primary-foreground ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                  className="h-4 w-4"
                  aria-hidden="true"
                >
                  <path d="M12.232 4.232a2.5 2.5 0 013.536 3.536l-1.225 1.224a.75.75 0 001.061 1.06l1.224-1.224a4 4 0 00-5.656-5.656l-3 3a4 4 0 00.225 5.865.75.75 0 00.977-1.138 2.5 2.5 0 01-.142-3.667l3-3z" />
                  <path d="M11.603 7.963a.75.75 0 00-.977 1.138 2.5 2.5 0 01.142 3.667l-3 3a2.5 2.5 0 01-3.536-3.536l1.225-1.224a.75.75 0 00-1.061-1.06l-1.224 1.224a4 4 0 105.656 5.656l3-3a4 4 0 00-.225-5.865z" />
                </svg>
                View Recipe
              </a>
              <button
                onClick={onEdit}
                className="inline-flex h-9 items-center justify-center rounded-md border border-input bg-background px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
              >
                Edit
              </button>
              <button
                onClick={onDelete}
                className="inline-flex h-9 items-center justify-center rounded-md border border-input bg-background px-3 text-sm font-medium text-destructive ring-offset-background transition-colors hover:bg-destructive hover:text-destructive-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
              >
                Delete
              </button>
            </>
          ) : (
            <>
              <button
                onClick={onSave}
                disabled={isSubmitting}
                className="inline-flex h-9 items-center justify-center rounded-md bg-primary px-3 text-sm font-medium text-primary-foreground ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
              >
                {isSubmitting ? 'Saving...' : 'Save'}
              </button>
              <button
                onClick={onCancel}
                disabled={isSubmitting}
                className="inline-flex h-9 items-center justify-center rounded-md border border-input bg-background px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
              >
                Cancel
              </button>
            </>
          )}
        </div>
      </div>

      {/* Content */}
      <div className="rounded-lg border border-border bg-card p-6">
        {mode === 'view' ? (
          <div className="space-y-6">
            {/* URL section */}
            <div>
              <h3 className="text-sm font-semibold text-muted-foreground">Recipe URL</h3>
              <a
                href={entry.url}
                target="_blank"
                rel="noopener noreferrer"
                className="mt-1 block break-all text-sm text-primary hover:underline"
              >
                {entry.url}
              </a>
            </div>

            {/* Notes section */}
            {entry.notes && (
              <div>
                <h3 className="text-sm font-semibold text-muted-foreground">Notes</h3>
                <div className="mt-1 max-h-[50vh] overflow-auto whitespace-pre-wrap break-words text-sm text-foreground">
                  {entry.notes}
                </div>
              </div>
            )}

            {/* Empty notes placeholder */}
            {!entry.notes && (
              <div>
                <h3 className="text-sm font-semibold text-muted-foreground">Notes</h3>
                <p className="mt-1 text-sm text-muted-foreground italic">No notes added</p>
              </div>
            )}
          </div>
        ) : (
          <CookbookEntryForm
            value={form}
            errors={errors}
            disabled={isSubmitting}
            submitLabel="Save changes"
            showCancel={true}
            onCancel={onCancel}
            onChange={onChange}
            onSubmit={onSave}
          />
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/cookbook/CookbookEntryForm.tsx
================================================
/**
 * CookbookEntryForm - Reusable form for create and edit operations
 * Renders URL, Title inputs and Notes textarea with inline validation errors
 */

import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { InlineFieldError } from '@/components/auth/InlineFieldError';
import type { CookbookEntryFormVM, CookbookEntryFormErrorsVM } from './cookbook.types';

interface CookbookEntryFormProps {
  value: CookbookEntryFormVM;
  errors: CookbookEntryFormErrorsVM;
  disabled?: boolean;
  submitLabel: string;
  showCancel?: boolean;
  onCancel?: () => void;
  onChange: (next: Partial<CookbookEntryFormVM>) => void;
  onSubmit: () => void;
}

export default function CookbookEntryForm({
  value,
  errors,
  disabled = false,
  submitLabel,
  showCancel = false,
  onCancel,
  onChange,
  onSubmit,
}: CookbookEntryFormProps) {
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit();
  };

  return (
    <form noValidate onSubmit={handleSubmit} className="space-y-6">
      {/* General error */}
      {errors.general && (
        <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
          {errors.general}
        </div>
      )}

      {/* URL field */}
      <div className="space-y-2">
        <Label htmlFor="url">
          Recipe URL <span className="text-destructive">*</span>
        </Label>
        <Input
          id="url"
          type="url"
          value={value.url}
          onChange={(e) => onChange({ url: e.target.value })}
          disabled={disabled}
          placeholder="https://example.com/recipe"
          aria-invalid={!!errors.url}
          aria-describedby={errors.url ? 'url-error' : undefined}
        />
        <InlineFieldError error={errors.url} />
      </div>

      {/* Title field */}
      <div className="space-y-2">
        <Label htmlFor="title">
          Title <span className="text-destructive">*</span>
        </Label>
        <Input
          id="title"
          type="text"
          value={value.title}
          onChange={(e) => onChange({ title: e.target.value })}
          disabled={disabled}
          placeholder="Recipe name"
          aria-invalid={!!errors.title}
          aria-describedby={errors.title ? 'title-error' : undefined}
        />
        <InlineFieldError error={errors.title} />
      </div>

      {/* Notes field - native textarea */}
      <div className="space-y-2">
        <Label htmlFor="notes">Notes</Label>
        <textarea
          id="notes"
          value={value.notes}
          onChange={(e) => onChange({ notes: e.target.value })}
          disabled={disabled}
          placeholder="Optional notes about this recipe..."
          rows={6}
          className="flex min-h-[120px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
          aria-invalid={!!errors.notes}
          aria-describedby={errors.notes ? 'notes-error' : undefined}
        />
        <InlineFieldError error={errors.notes} />
      </div>

      {/* Actions */}
      <div className="flex gap-3">
        <button
          type="submit"
          disabled={disabled}
          className="inline-flex h-10 items-center justify-center rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
        >
          {submitLabel}
        </button>
        {showCancel && onCancel && (
          <button
            type="button"
            onClick={onCancel}
            disabled={disabled}
            className="inline-flex h-10 items-center justify-center rounded-md border border-input bg-background px-4 py-2 text-sm font-medium ring-offset-background transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50"
          >
            Cancel
          </button>
        )}
      </div>
    </form>
  );
}



================================================
FILE: src/components/cookbook/CookbookEntryView.tsx
================================================
/**
 * CookbookEntryView - Detail controller for individual cookbook entries
 * Handles load, view/edit modes, and delete operations
 */

import { useId, useState, useEffect } from 'react';
import { toast } from 'sonner';
import useCookbookEntry from './useCookbookEntry';
import CookbookEntryDetail from './CookbookEntryDetail';
import { LoadingState } from '@/components/shared/LoadingState';
import { NotFoundState } from '@/components/shared/NotFoundState';
import { FullPageError } from '@/components/shared/FullPageError';
import { createFormFromDetail, areFormsEqual, isValidUrl } from './cookbook.types';
import type {
  CookbookEntryFormVM,
  CookbookEntryFormErrorsVM,
  CookbookEntryDetailVM,
} from './cookbook.types';
import type { UpdateCookbookEntryCommand, ApiErrorResponse } from '@/types';

interface CookbookEntryViewProps {
  entryId: string;
  isAuthenticated: boolean;
}

export default function CookbookEntryView({ entryId, isAuthenticated }: CookbookEntryViewProps) {
  const headingId = useId();

  // Fetch entry data
  const { data, isLoading, error, isNotFound, retry } = useCookbookEntry({ entryId });

  // Edit state
  const [mode, setMode] = useState<'view' | 'edit'>('view');
  const [form, setForm] = useState<CookbookEntryFormVM>({ url: '', title: '', notes: '' });
  const [errors, setErrors] = useState<CookbookEntryFormErrorsVM>({});
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [lastSavedEntry, setLastSavedEntry] = useState<CookbookEntryDetailVM | null>(null);

  // Initialize form when data loads
  useEffect(() => {
    if (data) {
      setForm(createFormFromDetail(data));
      setLastSavedEntry(data);
    }
  }, [data]);

  // Check if form is dirty
  const isDirty =
    lastSavedEntry !== null &&
    !areFormsEqual(form, createFormFromDetail(lastSavedEntry));

  /**
   * Handle edit mode toggle
   */
  const handleEdit = () => {
    setMode('edit');
    setErrors({});
  };

  /**
   * Handle cancel edit
   */
  const handleCancel = () => {
    if (lastSavedEntry) {
      setForm(createFormFromDetail(lastSavedEntry));
    }
    setErrors({});
    setMode('view');
  };

  /**
   * Handle form field changes
   */
  const handleChange = (next: Partial<CookbookEntryFormVM>) => {
    setForm((prev) => ({ ...prev, ...next }));

    // Clear field error on change
    if (next.url !== undefined && errors.url) {
      setErrors((prev) => ({ ...prev, url: undefined }));
    }
    if (next.title !== undefined && errors.title) {
      setErrors((prev) => ({ ...prev, title: undefined }));
    }
    if (next.notes !== undefined && errors.notes) {
      setErrors((prev) => ({ ...prev, notes: undefined }));
    }
    if (errors.general) {
      setErrors((prev) => ({ ...prev, general: undefined }));
    }
  };

  /**
   * Handle save (update)
   */
  const handleSave = async () => {
    if (!lastSavedEntry) return;

    // Check if anything changed
    if (!isDirty) {
      setErrors({ general: 'No changes to save.' });
      return;
    }

    setIsSaving(true);
    setErrors({});

    try {
      // Build command with only changed fields
      const command: UpdateCookbookEntryCommand = {};
      const lastForm = createFormFromDetail(lastSavedEntry);

      if (form.url.trim() !== lastForm.url) {
        // Validate URL if changed
        if (!form.url.trim()) {
          setErrors({ url: 'URL is required' });
          setIsSaving(false);
          return;
        }
        if (!isValidUrl(form.url)) {
          setErrors({ url: 'Please enter a valid URL starting with http:// or https://' });
          setIsSaving(false);
          return;
        }
        command.url = form.url.trim();
      }

      if (form.title.trim() !== lastForm.title) {
        // Validate title if changed
        if (!form.title.trim()) {
          setErrors({ title: 'Title is required' });
          setIsSaving(false);
          return;
        }
        command.title = form.title.trim();
      }

      if (form.notes !== lastForm.notes) {
        command.notes = form.notes.trim() || undefined;
      }

      // Ensure at least one field is present
      if (Object.keys(command).length === 0) {
        setErrors({ general: 'No changes to save.' });
        setIsSaving(false);
        return;
      }

      const response = await fetch(`/api/cookbook/${entryId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(command),
      });

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      // Handle 404 - entry not found or no longer accessible
      if (response.status === 404) {
        toast.error('Entry not found');
        window.location.href = '/cookbook';
        return;
      }

      // Handle validation errors (400)
      if (response.status === 400) {
        const errorData = (await response.json()) as ApiErrorResponse;
        const newErrors: CookbookEntryFormErrorsVM = {};

        if (errorData.error.details) {
          if (errorData.error.details.url) {
            newErrors.url = errorData.error.details.url;
          }
          if (errorData.error.details.title) {
            newErrors.title = errorData.error.details.title;
          }
          if (errorData.error.details.notes) {
            newErrors.notes = errorData.error.details.notes;
          }
          if (errorData.error.details.general) {
            newErrors.general = errorData.error.details.general;
          }
        }

        if (Object.keys(newErrors).length > 0) {
          setErrors(newErrors);
        } else {
          setErrors({ general: errorData.error.message });
        }
        return;
      }

      // Handle other errors
      if (!response.ok) {
        const errorData = (await response.json()) as ApiErrorResponse;
        toast.error(errorData.error.message || 'Failed to save changes');
        return;
      }

      // Success - update local state and exit edit mode
      const updatedData = await response.json();
      const updatedVM = {
        ...lastSavedEntry,
        url: updatedData.url,
        title: updatedData.title,
        notes: updatedData.notes ?? '',
      };
      setLastSavedEntry(updatedVM);
      setForm(createFormFromDetail(updatedVM));
      setMode('view');
      toast.success('Changes saved');
    } catch (err) {
      // Network error
      toast.error("Couldn't save changes. Check your connection.");
    } finally {
      setIsSaving(false);
    }
  };

  /**
   * Handle delete
   */
  const handleDelete = async () => {
    // Confirm deletion
    const confirmed = window.confirm('Delete this cookbook entry?');
    if (!confirmed) return;

    setIsDeleting(true);

    try {
      const response = await fetch(`/api/cookbook/${entryId}`, {
        method: 'DELETE',
      });

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      // Handle 404 - entry not found (already deleted or never existed)
      if (response.status === 404) {
        toast.error('Entry not found');
        window.location.href = '/cookbook';
        return;
      }

      // Handle other errors
      if (!response.ok) {
        const errorData = (await response.json()) as ApiErrorResponse;
        toast.error(errorData.error.message || 'Failed to delete entry');
        setIsDeleting(false);
        return;
      }

      // Success
      toast.success('Entry deleted');
      window.location.href = '/cookbook';
    } catch (err) {
      // Network error
      toast.error("Couldn't delete entry. Check your connection.");
      setIsDeleting(false);
    }
  };

  return (
    <section aria-labelledby={headingId} className="w-full">
      <div className="mb-6">
        <a
          href="/cookbook"
          className="text-sm text-muted-foreground hover:text-foreground transition-colors"
        >
          ← Back to Cookbook
        </a>
      </div>

      {/* Loading state */}
      {isLoading && (
        <div className="space-y-4">
          <div className="h-8 w-3/4 animate-pulse rounded bg-muted" />
          <div className="h-4 w-1/2 animate-pulse rounded bg-muted" />
          <div className="h-64 animate-pulse rounded-lg bg-muted" />
        </div>
      )}

      {/* Not found state */}
      {isNotFound && !isLoading && (
        <NotFoundState
          title="Entry not found"
          description="This cookbook entry doesn't exist or is no longer available."
          backHref="/cookbook"
          backLabel="Back to Cookbook"
        />
      )}

      {/* Error state */}
      {error && !isLoading && !isNotFound && (
        <FullPageError
          title={error.status === 500 ? 'Server error' : 'Something went wrong'}
          message={error.message}
          onRetry={retry}
        />
      )}

      {/* Success state - detail view */}
      {lastSavedEntry && !isLoading && !isNotFound && !error && (
        <CookbookEntryDetail
          entry={lastSavedEntry}
          mode={mode}
          form={form}
          errors={errors}
          isSubmitting={isSaving || isDeleting}
          onEdit={handleEdit}
          onCancel={handleCancel}
          onChange={handleChange}
          onSave={handleSave}
          onDelete={handleDelete}
        />
      )}
    </section>
  );
}



================================================
FILE: src/components/cookbook/CookbookListView.tsx
================================================
/**
 * CookbookListView - Top-level list view for cookbook entries
 * Fetches and displays paginated list of user's saved recipe links
 */

import { useId } from 'react';
import useCookbookEntries from './useCookbookEntries';
import CookbookEntryCard from './CookbookEntryCard';
import { LoadingState } from '@/components/shared/LoadingState';
import { EmptyState } from '@/components/shared/EmptyState';
import { FullPageError } from '@/components/shared/FullPageError';
import { PaginationControls } from '@/components/shared/PaginationControls';
import type { CookbookSort } from './cookbook.types';

interface CookbookListViewProps {
  isAuthenticated: boolean;
  defaultSort?: CookbookSort;
  defaultLimit?: number;
}

export default function CookbookListView({
  isAuthenticated,
  defaultSort = 'newest',
  defaultLimit = 20,
}: CookbookListViewProps) {
  const headingId = useId();

  // Fetch entries with hook
  const { data, isLoading, error, setSort, goPrev, goNext, retry } = useCookbookEntries({
    sort: defaultSort,
    page: 1,
    limit: defaultLimit,
  });

  return (
    <section aria-labelledby={headingId} className="w-full">
      {/* Header */}
      <div className="mb-6 flex flex-col gap-4 sm:flex-row sm:items-start sm:justify-between">
        <div>
          <h2 id={headingId} className="text-3xl font-bold tracking-tight">
            Cookbook
          </h2>
          <p className="mt-1 text-muted-foreground">Private recipe links you've saved.</p>
        </div>
        <a
          href="/cookbook/new"
          className="inline-flex h-10 items-center justify-center rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground ring-offset-background transition-colors hover:bg-primary/90 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
        >
          New entry
        </a>
      </div>

      {/* Sort controls */}
      {!isLoading && !error && data && data.entries.length > 0 && (
        <div className="mb-4 flex items-center gap-2">
          <label htmlFor="sort-select" className="text-sm text-muted-foreground">
            Sort by:
          </label>
          <select
            id="sort-select"
            className="h-9 rounded-md border border-input bg-background px-3 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
            defaultValue={defaultSort}
            onChange={(e) => setSort(e.target.value as CookbookSort)}
          >
            <option value="newest">Newest first</option>
            <option value="oldest">Oldest first</option>
            <option value="title_asc">Title (A-Z)</option>
          </select>
        </div>
      )}

      {/* Content area */}
      <div className="space-y-6">
        {/* Loading state */}
        {isLoading && <LoadingState count={6} />}

        {/* Error state */}
        {error && !isLoading && (
          <FullPageError
            title={error.status === 500 ? 'Server error' : 'Something went wrong'}
            message={error.message}
            onRetry={retry}
          />
        )}

        {/* Empty state */}
        {!isLoading && !error && data && data.entries.length === 0 && (
          <EmptyState
            title="No cookbook entries yet"
            description="Start saving your favorite recipe links by creating your first entry."
          />
        )}

        {/* Success state - entries grid */}
        {!isLoading && !error && data && data.entries.length > 0 && (
          <>
            <ul role="list" className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
              {data.entries.map((entry) => (
                <CookbookEntryCard key={entry.id} entry={entry} />
              ))}
            </ul>

            {/* Pagination */}
            <PaginationControls
              currentPage={data.pagination.page}
              totalPages={data.pagination.totalPages}
              isLoading={isLoading}
              onPrev={goPrev}
              onNext={goNext}
            />
          </>
        )}
      </div>
    </section>
  );
}



================================================
FILE: src/components/cookbook/useCookbookEntries.ts
================================================
/**
 * useCookbookEntries - Custom hook for fetching cookbook entry list
 * Handles pagination, sorting, and error states
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import type { ListCookbookEntriesResponseDTO, ApiErrorResponse } from '@/types';
import { toListVM } from './cookbook.types';
import type {
  CookbookListVM,
  CookbookListErrorVM,
  CookbookSort,
} from './cookbook.types';

interface UseCookbookEntriesParams {
  sort?: CookbookSort;
  page?: number;
  limit?: number;
}

interface UseCookbookEntriesResult {
  data: CookbookListVM | null;
  isLoading: boolean;
  error: CookbookListErrorVM | null;
  setSort: (next: CookbookSort) => void;
  goPrev: () => void;
  goNext: () => void;
  retry: () => void;
}

/**
 * Parse API error response
 */
async function parseApiError(response: Response): Promise<CookbookListErrorVM> {
  try {
    const data = (await response.json()) as ApiErrorResponse;
    return {
      kind: 'http',
      status: response.status,
      message: data.error.message,
      api: data,
    };
  } catch {
    return {
      kind: 'http',
      status: response.status,
      message: `Request failed with status ${response.status}`,
    };
  }
}

export default function useCookbookEntries({
  sort = 'newest',
  page = 1,
  limit = 20,
}: UseCookbookEntriesParams = {}): UseCookbookEntriesResult {
  const [data, setData] = useState<CookbookListVM | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<CookbookListErrorVM | null>(null);
  const [currentSort, setCurrentSort] = useState<CookbookSort>(sort);
  const [currentPage, setCurrentPage] = useState(page);

  // Abort controller for cleanup
  const abortControllerRef = useRef<AbortController | null>(null);

  /**
   * Fetch cookbook entries from API
   */
  const fetchEntries = useCallback(async () => {
    // Cancel any in-flight request
    abortControllerRef.current?.abort();

    // Create new abort controller
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setIsLoading(true);
    setError(null);

    try {
      // Build query params
      const params = new URLSearchParams({
        sort: currentSort,
        page: String(currentPage),
        limit: String(limit),
      });

      const response = await fetch(`/api/cookbook?${params.toString()}`, {
        signal: abortController.signal,
      });

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      if (!response.ok) {
        const errorData = await parseApiError(response);
        setError(errorData);
        setData(null);
        return;
      }

      // Success - parse and map to VM
      const dto = (await response.json()) as ListCookbookEntriesResponseDTO;
      const vm = toListVM(dto);

      setData(vm);
      setError(null);
    } catch (err) {
      // Handle abort and network errors
      if (err instanceof Error && err.name === 'AbortError') {
        // Request was cancelled, ignore
        return;
      }

      // Network error
      setError({
        kind: 'network',
        message: "Couldn't load cookbook entries. Check your connection.",
      });
      setData(null);
    } finally {
      setIsLoading(false);
    }
  }, [currentSort, currentPage, limit]);

  /**
   * Set sort and reset to page 1
   */
  const setSort = useCallback((next: CookbookSort) => {
    setCurrentSort(next);
    setCurrentPage(1);
  }, []);

  /**
   * Go to previous page
   */
  const goPrev = useCallback(() => {
    setCurrentPage((prev) => Math.max(1, prev - 1));
  }, []);

  /**
   * Go to next page
   */
  const goNext = useCallback(() => {
    setCurrentPage((prev) => {
      if (data && prev < data.pagination.totalPages) {
        return prev + 1;
      }
      return prev;
    });
  }, [data]);

  /**
   * Retry current request
   */
  const retry = useCallback(() => {
    fetchEntries();
  }, [fetchEntries]);

  /**
   * Fetch data on mount and when dependencies change
   */
  useEffect(() => {
    fetchEntries();

    // Cleanup on unmount
    return () => {
      abortControllerRef.current?.abort();
    };
  }, [fetchEntries]);

  return {
    data,
    isLoading,
    error,
    setSort,
    goPrev,
    goNext,
    retry,
  };
}



================================================
FILE: src/components/cookbook/useCookbookEntry.ts
================================================
/**
 * useCookbookEntry - Custom hook for fetching single cookbook entry
 * Handles UUID validation, not-found states, and error handling
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import type { GetCookbookEntryResponseDTO, ApiErrorResponse } from '@/types';
import { isUuid, toDetailVM } from './cookbook.types';
import type { CookbookEntryDetailVM, CookbookEntryErrorVM } from './cookbook.types';

interface UseCookbookEntryParams {
  entryId: string;
}

interface UseCookbookEntryResult {
  data: CookbookEntryDetailVM | null;
  isLoading: boolean;
  error: CookbookEntryErrorVM | null;
  isNotFound: boolean;
  retry: () => void;
}

/**
 * Parse API error response
 */
async function parseApiError(response: Response): Promise<CookbookEntryErrorVM> {
  try {
    const data = (await response.json()) as ApiErrorResponse;
    return {
      kind: 'http',
      status: response.status,
      message: data.error.message,
      api: data,
    };
  } catch {
    return {
      kind: 'http',
      status: response.status,
      message: `Request failed with status ${response.status}`,
    };
  }
}

export default function useCookbookEntry({
  entryId,
}: UseCookbookEntryParams): UseCookbookEntryResult {
  const [data, setData] = useState<CookbookEntryDetailVM | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<CookbookEntryErrorVM | null>(null);
  const [isNotFound, setIsNotFound] = useState(false);

  // Abort controller for cleanup
  const abortControllerRef = useRef<AbortController | null>(null);

  /**
   * Fetch entry detail from API
   */
  const fetchEntry = useCallback(async () => {
    // Pre-validate UUID to avoid unnecessary API call
    if (!isUuid(entryId)) {
      setIsLoading(false);
      setIsNotFound(true);
      setError(null);
      setData(null);
      return;
    }

    // Cancel any in-flight request
    abortControllerRef.current?.abort();

    // Create new abort controller
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setIsLoading(true);
    setError(null);
    setIsNotFound(false);

    try {
      const response = await fetch(`/api/cookbook/${entryId}`, {
        signal: abortController.signal,
      });

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      if (!response.ok) {
        // Handle 404 or 400 (invalid UUID) as not found
        if (response.status === 404 || response.status === 400) {
          setIsNotFound(true);
          setData(null);
          setError(null);
        } else {
          // Handle other errors (500, network, etc.)
          const errorData = await parseApiError(response);
          setError(errorData);
          setData(null);
          setIsNotFound(false);
        }
        return;
      }

      // Success - parse and map to VM
      const dto = (await response.json()) as GetCookbookEntryResponseDTO;
      const vm = toDetailVM(dto);

      setData(vm);
      setError(null);
      setIsNotFound(false);
    } catch (err) {
      // Handle abort and network errors
      if (err instanceof Error && err.name === 'AbortError') {
        // Request was cancelled, ignore
        return;
      }

      // Network error
      setError({
        kind: 'network',
        message: "Couldn't load entry. Check your connection.",
      });
      setData(null);
      setIsNotFound(false);
    } finally {
      setIsLoading(false);
    }
  }, [entryId]);

  /**
   * Retry fetching data
   */
  const retry = useCallback(() => {
    fetchEntry();
  }, [fetchEntry]);

  /**
   * Fetch data on mount and when dependencies change
   */
  useEffect(() => {
    fetchEntry();

    // Cleanup on unmount
    return () => {
      abortControllerRef.current?.abort();
    };
  }, [fetchEntry]);

  return {
    data,
    isLoading,
    error,
    isNotFound,
    retry,
  };
}



================================================
FILE: src/components/home/home.types.ts
================================================
/**
 * View-specific types for the Home view
 * These types are used to manage state and presentation logic
 */

import type { DifficultyLevel, ApiErrorResponse } from "../../types";
import type { ContentCardItemVM } from "../content/content.types";

/**
 * Home view mode - determines which data to fetch and how to display it
 */
export type HomeViewMode = "anonymous" | "authenticated";

/**
 * Error information for feed loading failures
 */
export interface HomeFeedErrorVM {
  kind: "network" | "http" | "unknown";
  status?: number; // present for HTTP errors
  message: string; // user-friendly message
  api?: ApiErrorResponse; // present if server returned structured error
}

/**
 * Normalized content item for ContentCard
 * Alias for shared ContentCardItemVM to maintain backward compatibility
 * @deprecated Use ContentCardItemVM from content.types.ts instead
 */
export type HomeContentItemVM = ContentCardItemVM;

/**
 * Complete state for the Home view feeds
 */
export interface HomeFeedStateVM {
  mode: HomeViewMode;
  selectedLevel?: DifficultyLevel;

  tutorials: ContentCardItemVM[];
  articles: ContentCardItemVM[];

  isLoadingTutorials: boolean;
  isLoadingArticles: boolean;
  tutorialsError: HomeFeedErrorVM | null;
  articlesError: HomeFeedErrorVM | null;
}

/**
 * Optional session model for future authentication support
 */
export interface SessionVM {
  userId: string;
  username?: string;
  selectedLevel?: DifficultyLevel;
}



================================================
FILE: src/components/home/HomeSection.tsx
================================================
/**
 * HomeSection - Section wrapper for Tutorials or Articles feed
 * Handles loading, error, empty, and success states
 */

import { useId } from "react";
import type { HomeContentItemVM, HomeFeedErrorVM } from "./home.types";
import { SectionHeader } from "../shared/SectionHeader";
import { LoadingState } from "../shared/LoadingState";
import { EmptyState } from "../shared/EmptyState";
import { FullPageError } from "../shared/FullPageError";
import { ContentCard } from "../content/ContentCard";

export type HomeSectionKind = "tutorials" | "articles";

interface HomeSectionProps {
  kind: HomeSectionKind;
  title: string;
  description: string;
  items: HomeContentItemVM[];
  isLoading: boolean;
  error: HomeFeedErrorVM | null;
  onRetry: () => void;
}

export function HomeSection({
  kind,
  title,
  description,
  items,
  isLoading,
  error,
  onRetry,
}: HomeSectionProps) {
  const headingId = useId();

  return (
    <section aria-labelledby={headingId}>
      <SectionHeader id={headingId} title={title} description={description} />

      {/* Loading State */}
      {isLoading && <LoadingState count={5} />}

      {/* Error State */}
      {!isLoading && error && (
        <FullPageError
          title={`Couldn't load ${kind}`}
          message={error.message}
          onRetry={onRetry}
        />
      )}

      {/* Empty State */}
      {!isLoading && !error && items.length === 0 && (
        <EmptyState
          title={`No ${kind} available`}
          description={`Check back later for new ${kind}.`}
        />
      )}

      {/* Success State - Content Grid */}
      {!isLoading && !error && items.length > 0 && (
        <ul role="list" className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {items.map((item) => (
            <ContentCard key={item.id} item={item} />
          ))}
        </ul>
      )}
    </section>
  );
}



================================================
FILE: src/components/home/HomeView.tsx
================================================
/**
 * HomeView - Main container for the Home page
 * Fetches and displays tutorials and articles feeds
 */

import type { DifficultyLevel } from "../../types";
import type { HomeViewMode } from "./home.types";
import { useHomeFeeds } from "../hooks/useHomeFeeds";
import { HomeSection } from "./HomeSection";

interface HomeViewProps {
  initialMode?: HomeViewMode;
  selectedLevel?: DifficultyLevel;
}

export default function HomeView({ initialMode, selectedLevel }: HomeViewProps) {
  const {
    mode,
    tutorials,
    articles,
    isLoadingTutorials,
    isLoadingArticles,
    tutorialsError,
    articlesError,
    refetchTutorials,
    refetchArticles,
  } = useHomeFeeds({ initialMode, selectedLevel });

  // Determine section titles and descriptions based on mode
  const tutorialsSectionTitle =
    mode === "authenticated" ? "Recommended Tutorials" : "Newest Tutorials";
  const tutorialsSectionDescription =
    mode === "authenticated"
      ? `Tutorials matched to your ${selectedLevel?.toLowerCase() || ""} level`
      : "Latest practical and theoretical cooking tutorials";

  const articlesSectionTitle =
    mode === "authenticated" ? "Recommended Articles" : "Newest Articles";
  const articlesSectionDescription =
    mode === "authenticated"
      ? `Articles matched to your ${selectedLevel?.toLowerCase() || ""} level`
      : "Latest cooking knowledge and technique articles";

  return (
    <div className="mx-auto w-full max-w-6xl px-4 py-6" suppressHydrationWarning>
      {/* Tutorials Section */}
      <HomeSection
        kind="tutorials"
        title={tutorialsSectionTitle}
        description={tutorialsSectionDescription}
        items={tutorials}
        isLoading={isLoadingTutorials}
        error={tutorialsError}
        onRetry={refetchTutorials}
      />

      {/* Articles Section */}
      <div className="mt-12" suppressHydrationWarning>
        <HomeSection
          kind="articles"
          title={articlesSectionTitle}
          description={articlesSectionDescription}
          items={articles}
          isLoading={isLoadingArticles}
          error={articlesError}
          onRetry={refetchArticles}
        />
      </div>
    </div>
  );
}



================================================
FILE: src/components/hooks/useHomeFeeds.ts
================================================
/**
 * Custom hook for managing Home view data fetching
 * Handles parallel fetching of tutorials and articles with proper error handling
 */

import { useState, useEffect, useCallback, useRef } from "react";
import type {
  DifficultyLevel,
  ListTutorialsResponseDTO,
  ListArticlesResponseDTO,
  TutorialListItemDTO,
  ArticleListItemDTO,
  ApiErrorResponse,
} from "../../types";
import type {
  HomeViewMode,
  HomeFeedStateVM,
  HomeContentItemVM,
  HomeFeedErrorVM,
} from "../home/home.types";

interface UseHomeFeedsOptions {
  initialMode?: HomeViewMode;
  selectedLevel?: DifficultyLevel;
}

interface UseHomeFeedsReturn extends HomeFeedStateVM {
  refetchTutorials: () => void;
  refetchArticles: () => void;
  refetchAll: () => void;
}

/**
 * Helper: Check if content was created within the last N days
 */
function isCreatedWithinDays(createdAt: string, days: number): boolean {
  try {
    const created = new Date(createdAt);
    const now = new Date();
    const diffMs = now.getTime() - created.getTime();
    const diffDays = diffMs / (1000 * 60 * 60 * 24);
    return diffDays <= days;
  } catch {
    return false;
  }
}

/**
 * Helper: Map tutorial DTO to view model
 */
function mapTutorialToVM(
  dto: TutorialListItemDTO,
  mode: HomeViewMode
): HomeContentItemVM {
  return {
    type: "tutorial",
    id: dto.id,
    title: dto.title,
    summary: dto.summary,
    level: dto.level,
    difficultyWeight: dto.difficulty_weight,
    createdAt: dto.created_at,
    href: `/tutorials/${dto.id}`,
    category: dto.category,
    isNew: isCreatedWithinDays(dto.created_at, 7),
    isCompleted: mode === "authenticated" ? dto.is_completed : undefined,
  };
}

/**
 * Helper: Map article DTO to view model
 */
function mapArticleToVM(
  dto: ArticleListItemDTO,
  mode: HomeViewMode
): HomeContentItemVM {
  return {
    type: "article",
    id: dto.id,
    title: dto.title,
    summary: dto.summary,
    level: dto.level,
    difficultyWeight: dto.difficulty_weight,
    createdAt: dto.created_at,
    href: `/articles/${dto.id}`,
    isNew: isCreatedWithinDays(dto.created_at, 7),
    isCompleted: mode === "authenticated" ? dto.is_completed : undefined,
    completedAt: mode === "authenticated" ? dto.completed_at : undefined,
  };
}

/**
 * Helper: Parse API error response
 */
async function parseApiError(response: Response): Promise<HomeFeedErrorVM> {
  try {
    const data = (await response.json()) as ApiErrorResponse;
    return {
      kind: "http",
      status: response.status,
      message: data.error.message,
      api: data,
    };
  } catch {
    return {
      kind: "http",
      status: response.status,
      message: `Request failed with status ${response.status}`,
    };
  }
}

/**
 * Custom hook for fetching and managing Home feeds
 */
export function useHomeFeeds(options: UseHomeFeedsOptions = {}): UseHomeFeedsReturn {
  const { initialMode = "anonymous", selectedLevel } = options;

  // Determine mode based on selectedLevel availability
  const mode: HomeViewMode =
    selectedLevel && initialMode === "authenticated" ? "authenticated" : "anonymous";

  // State
  const [tutorials, setTutorials] = useState<HomeContentItemVM[]>([]);
  const [articles, setArticles] = useState<HomeContentItemVM[]>([]);
  const [isLoadingTutorials, setIsLoadingTutorials] = useState(true);
  const [isLoadingArticles, setIsLoadingArticles] = useState(true);
  const [tutorialsError, setTutorialsError] = useState<HomeFeedErrorVM | null>(null);
  const [articlesError, setArticlesError] = useState<HomeFeedErrorVM | null>(null);

  // Abort controllers for cleanup
  const tutorialsAbortRef = useRef<AbortController | null>(null);
  const articlesAbortRef = useRef<AbortController | null>(null);

  /**
   * Fetch tutorials from API
   */
  const fetchTutorials = useCallback(async () => {
    // Cancel any in-flight request
    tutorialsAbortRef.current?.abort();
    const abortController = new AbortController();
    tutorialsAbortRef.current = abortController;

    setIsLoadingTutorials(true);
    setTutorialsError(null);

    try {
      // Build query params based on mode
      const params = new URLSearchParams({
        limit: "5",
        page: "1",
        include_completed: mode === "authenticated" ? "true" : "false",
      });

      if (mode === "authenticated" && selectedLevel) {
        params.set("level", selectedLevel);
        params.set("sort", "difficulty_asc");
      } else {
        params.set("sort", "newest");
      }

      const response = await fetch(`/api/tutorials?${params.toString()}`, {
        signal: abortController.signal,
      });

      if (!response.ok) {
        const error = await parseApiError(response);
        setTutorialsError(error);
        setTutorials([]);
        return;
      }

      const data = (await response.json()) as ListTutorialsResponseDTO;
      const mappedTutorials = data.tutorials.map((dto) => mapTutorialToVM(dto, mode));
      setTutorials(mappedTutorials);
      setTutorialsError(null);
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        // Request was cancelled, ignore
        return;
      }

      setTutorialsError({
        kind: "network",
        message: "Couldn't load tutorials. Check your connection.",
      });
      setTutorials([]);
    } finally {
      if (!abortController.signal.aborted) {
        setIsLoadingTutorials(false);
      }
    }
  }, [mode, selectedLevel]);

  /**
   * Fetch articles from API
   */
  const fetchArticles = useCallback(async () => {
    // Cancel any in-flight request
    articlesAbortRef.current?.abort();
    const abortController = new AbortController();
    articlesAbortRef.current = abortController;

    setIsLoadingArticles(true);
    setArticlesError(null);

    try {
      // Build query params based on mode
      const params = new URLSearchParams({
        limit: "5",
        page: "1",
        include_completed: mode === "authenticated" ? "true" : "false",
      });

      if (mode === "authenticated" && selectedLevel) {
        params.set("level", selectedLevel);
        params.set("sort", "difficulty_asc");
      } else {
        params.set("sort", "newest");
      }

      const response = await fetch(`/api/articles?${params.toString()}`, {
        signal: abortController.signal,
      });

      if (!response.ok) {
        const error = await parseApiError(response);
        setArticlesError(error);
        setArticles([]);
        return;
      }

      const data = (await response.json()) as ListArticlesResponseDTO;
      const mappedArticles = data.articles.map((dto) => mapArticleToVM(dto, mode));
      setArticles(mappedArticles);
      setArticlesError(null);
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        // Request was cancelled, ignore
        return;
      }

      setArticlesError({
        kind: "network",
        message: "Couldn't load articles. Check your connection.",
      });
      setArticles([]);
    } finally {
      if (!abortController.signal.aborted) {
        setIsLoadingArticles(false);
      }
    }
  }, [mode, selectedLevel]);

  /**
   * Refetch functions
   */
  const refetchTutorials = useCallback(() => {
    fetchTutorials();
  }, [fetchTutorials]);

  const refetchArticles = useCallback(() => {
    fetchArticles();
  }, [fetchArticles]);

  const refetchAll = useCallback(() => {
    fetchTutorials();
    fetchArticles();
  }, [fetchTutorials, fetchArticles]);

  // Initial fetch on mount and when mode/selectedLevel changes
  useEffect(() => {
    fetchTutorials();
    fetchArticles();

    // Cleanup on unmount
    return () => {
      tutorialsAbortRef.current?.abort();
      articlesAbortRef.current?.abort();
    };
  }, [fetchTutorials, fetchArticles]);

  return {
    mode,
    selectedLevel,
    tutorials,
    articles,
    isLoadingTutorials,
    isLoadingArticles,
    tutorialsError,
    articlesError,
    refetchTutorials,
    refetchArticles,
    refetchAll,
  };
}



================================================
FILE: src/components/hooks/useLearningFeed.ts
================================================
/**
 * Custom hook for managing Learning view data fetching
 * Handles aggregated (all) and single-type (tutorials/articles) modes
 * with pagination, filtering, and proper error handling
 */

import { useState, useEffect, useCallback, useRef } from "react";
import type {
  DifficultyLevel,
  ListTutorialsResponseDTO,
  ListArticlesResponseDTO,
  TutorialListItemDTO,
  ArticleListItemDTO,
  ApiErrorResponse,
} from "../../types";
import type { ContentCardItemVM } from "../content/content.types";
import type {
  LearningTypeFilter,
  LearningLevelFilter,
  LearningFeedErrorVM,
  LearningPaginationVM,
} from "../learning/learning.types";

interface UseLearningFeedOptions {
  isAuthenticated: boolean;
  userSelectedLevel?: DifficultyLevel;
  initialLevelFilter: LearningLevelFilter;
  initialTypeFilter?: LearningTypeFilter;
}

interface UseLearningFeedReturn {
  type: LearningTypeFilter;
  level: LearningLevelFilter;
  page: number;
  items: ContentCardItemVM[];
  pagination: LearningPaginationVM;
  isLoading: boolean;
  error: LearningFeedErrorVM | null;
  setType: (nextType: LearningTypeFilter) => void;
  setLevel: (nextLevel: LearningLevelFilter) => void;
  goPrev: () => void;
  goNext: () => void;
  retry: () => void;
}

/**
 * Helper: Check if content was created within the last N days
 */
function isCreatedWithinDays(createdAt: string, days: number): boolean {
  try {
    const created = new Date(createdAt);
    const now = new Date();
    const diffMs = now.getTime() - created.getTime();
    const diffDays = diffMs / (1000 * 60 * 60 * 24);
    return diffDays <= days;
  } catch {
    return false;
  }
}

/**
 * Helper: Map tutorial DTO to view model
 */
function mapTutorialToVM(
  dto: TutorialListItemDTO,
  isAuthenticated: boolean
): ContentCardItemVM {
  return {
    type: "tutorial",
    id: dto.id,
    title: dto.title,
    summary: dto.summary,
    level: dto.level,
    difficultyWeight: dto.difficulty_weight,
    createdAt: dto.created_at,
    href: `/tutorials/${dto.id}`,
    category: dto.category,
    isNew: isCreatedWithinDays(dto.created_at, 7),
    isCompleted: isAuthenticated ? dto.is_completed : undefined,
  };
}

/**
 * Helper: Map article DTO to view model
 */
function mapArticleToVM(
  dto: ArticleListItemDTO,
  isAuthenticated: boolean
): ContentCardItemVM {
  return {
    type: "article",
    id: dto.id,
    title: dto.title,
    summary: dto.summary,
    level: dto.level,
    difficultyWeight: dto.difficulty_weight,
    createdAt: dto.created_at,
    href: `/articles/${dto.id}`,
    isNew: isCreatedWithinDays(dto.created_at, 7),
    isCompleted: isAuthenticated ? dto.is_completed : undefined,
    completedAt: isAuthenticated ? dto.completed_at : undefined,
  };
}

/**
 * Helper: Parse API error response
 */
async function parseApiError(response: Response): Promise<LearningFeedErrorVM> {
  try {
    const data = (await response.json()) as ApiErrorResponse;
    return {
      kind: "http",
      status: response.status,
      message: data.error.message,
      api: data,
    };
  } catch {
    return {
      kind: "http",
      status: response.status,
      message: `Request failed with status ${response.status}`,
    };
  }
}

/**
 * Helper: Build query params for API requests
 */
function buildQueryParams(
  page: number,
  limit: number,
  level: LearningLevelFilter,
  isAuthenticated: boolean
): URLSearchParams {
  const params = new URLSearchParams({
    limit: String(limit),
    page: String(page),
    sort: "newest",
    include_completed: isAuthenticated ? "true" : "false",
  });

  // Only add level if it's not "ALL"
  if (level !== "ALL") {
    params.set("level", level);
  }

  return params;
}

/**
 * Custom hook for fetching and managing Learning feed
 */
export function useLearningFeed(options: UseLearningFeedOptions): UseLearningFeedReturn {
  const { isAuthenticated, userSelectedLevel, initialLevelFilter, initialTypeFilter = "all" } =
    options;

  // Filter state
  const [type, setTypeState] = useState<LearningTypeFilter>(initialTypeFilter);
  const [level, setLevelState] = useState<LearningLevelFilter>(initialLevelFilter);
  const [page, setPage] = useState(1);

  // Data state
  const [items, setItems] = useState<ContentCardItemVM[]>([]);
  const [pagination, setPagination] = useState<LearningPaginationVM>({
    page: 1,
    totalPages: 1,
    totalItems: 0,
    pageSize: 10,
  });

  // UI state
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<LearningFeedErrorVM | null>(null);

  // Abort controllers for cleanup
  const tutorialsAbortRef = useRef<AbortController | null>(null);
  const articlesAbortRef = useRef<AbortController | null>(null);

  /**
   * Fetch tutorials from API
   */
  const fetchTutorials = useCallback(
    async (currentPage: number, limit: number, signal: AbortSignal) => {
      const params = buildQueryParams(currentPage, limit, level, isAuthenticated);
      const response = await fetch(`/api/tutorials?${params.toString()}`, { signal });

      if (!response.ok) {
        throw await parseApiError(response);
      }

      return (await response.json()) as ListTutorialsResponseDTO;
    },
    [level, isAuthenticated]
  );

  /**
   * Fetch articles from API
   */
  const fetchArticles = useCallback(
    async (currentPage: number, limit: number, signal: AbortSignal) => {
      const params = buildQueryParams(currentPage, limit, level, isAuthenticated);
      const response = await fetch(`/api/articles?${params.toString()}`, { signal });

      if (!response.ok) {
        throw await parseApiError(response);
      }

      return (await response.json()) as ListArticlesResponseDTO;
    },
    [level, isAuthenticated]
  );

  /**
   * Fetch data based on current type filter
   */
  const fetchData = useCallback(async () => {
    // Cancel any in-flight requests
    tutorialsAbortRef.current?.abort();
    articlesAbortRef.current?.abort();

    setIsLoading(true);
    setError(null);

    try {
      if (type === "all") {
        // Aggregated mode: fetch both in parallel
        const tutorialsAbort = new AbortController();
        const articlesAbort = new AbortController();
        tutorialsAbortRef.current = tutorialsAbort;
        articlesAbortRef.current = articlesAbort;

        const [tutorialsData, articlesData] = await Promise.all([
          fetchTutorials(page, 5, tutorialsAbort.signal),
          fetchArticles(page, 5, articlesAbort.signal),
        ]);

        // Map to view models
        const tutorialItems = tutorialsData.tutorials.map((dto) =>
          mapTutorialToVM(dto, isAuthenticated)
        );
        const articleItems = articlesData.articles.map((dto) =>
          mapArticleToVM(dto, isAuthenticated)
        );

        // Merge and sort by createdAt desc
        const combined = [...tutorialItems, ...articleItems].sort((a, b) => {
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        });

        // Take first 10 items
        const displayItems = combined.slice(0, 10);

        // Compute combined pagination
        const combinedTotalItems =
          tutorialsData.pagination.total_items + articlesData.pagination.total_items;
        const combinedPageSize = 10;
        const combinedTotalPages = Math.ceil(combinedTotalItems / combinedPageSize);

        setItems(displayItems);
        setPagination({
          page,
          totalPages: Math.max(combinedTotalPages, 1),
          totalItems: combinedTotalItems,
          pageSize: combinedPageSize,
        });
      } else {
        // Single type mode
        const abortController = new AbortController();
        tutorialsAbortRef.current = abortController;

        let data: ListTutorialsResponseDTO | ListArticlesResponseDTO;
        let mappedItems: ContentCardItemVM[];

        if (type === "tutorials") {
          data = await fetchTutorials(page, 10, abortController.signal);
          mappedItems = data.tutorials.map((dto) => mapTutorialToVM(dto, isAuthenticated));
        } else {
          data = await fetchArticles(page, 10, abortController.signal);
          mappedItems = data.articles.map((dto) => mapArticleToVM(dto, isAuthenticated));
        }

        setItems(mappedItems);
        setPagination({
          page,
          totalPages: Math.max(data.pagination.total_pages, 1),
          totalItems: data.pagination.total_items,
          pageSize: 10,
        });
      }

      setError(null);
    } catch (err) {
      if (err instanceof Error && err.name === "AbortError") {
        // Request was cancelled, ignore
        return;
      }

      if (typeof err === "object" && err !== null && "kind" in err) {
        setError(err as LearningFeedErrorVM);
      } else {
        setError({
          kind: "network",
          message: "Couldn't load learning content. Check your connection.",
        });
      }
      setItems([]);
      setPagination({
        page: 1,
        totalPages: 1,
        totalItems: 0,
        pageSize: 10,
      });
    } finally {
      setIsLoading(false);
    }
  }, [type, level, page, isAuthenticated, fetchTutorials, fetchArticles]);

  /**
   * Set type filter and reset to page 1
   */
  const setType = useCallback((nextType: LearningTypeFilter) => {
    setTypeState(nextType);
    setPage(1);
  }, []);

  /**
   * Set level filter and reset to page 1
   */
  const setLevel = useCallback((nextLevel: LearningLevelFilter) => {
    setLevelState(nextLevel);
    setPage(1);
  }, []);

  /**
   * Go to previous page
   */
  const goPrev = useCallback(() => {
    setPage((prev) => Math.max(1, prev - 1));
  }, []);

  /**
   * Go to next page
   */
  const goNext = useCallback(() => {
    setPage((prev) => Math.min(pagination.totalPages, prev + 1));
  }, [pagination.totalPages]);

  /**
   * Retry current request
   */
  const retry = useCallback(() => {
    fetchData();
  }, [fetchData]);

  // Fetch data when dependencies change
  useEffect(() => {
    fetchData();

    // Cleanup on unmount
    return () => {
      tutorialsAbortRef.current?.abort();
      articlesAbortRef.current?.abort();
    };
  }, [fetchData]);

  return {
    type,
    level,
    page,
    items,
    pagination,
    isLoading,
    error,
    setType,
    setLevel,
    goPrev,
    goNext,
    retry,
  };
}



================================================
FILE: src/components/learning/FiltersBar.tsx
================================================
/**
 * FiltersBar - Container for Learning view filters
 * Displays Type and Level filters with context labels
 */

import type { DifficultyLevel } from "../../types";
import type { LearningTypeFilter, LearningLevelFilter } from "./learning.types";
import { TypeFilter } from "./TypeFilter";
import { LevelFilter } from "./LevelFilter";

interface FiltersBarProps {
  type: LearningTypeFilter;
  level: LearningLevelFilter;
  userSelectedLevel?: DifficultyLevel;
  onTypeChange: (next: LearningTypeFilter) => void;
  onLevelChange: (next: LearningLevelFilter) => void;
}

export function FiltersBar({
  type,
  level,
  userSelectedLevel,
  onTypeChange,
  onLevelChange,
}: FiltersBarProps) {
  return (
    <div className="flex flex-col gap-4">
      {/* Filters row */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-end sm:gap-6">
        {/* Left: Filter controls */}
        <div className="flex flex-col gap-4 sm:flex-row sm:gap-6">
          <TypeFilter value={type} onChange={onTypeChange} />
          <LevelFilter
            value={level}
            userSelectedLevel={userSelectedLevel}
            onChange={onLevelChange}
          />
        </div>

        {/* Right: Context label */}
        <div className="flex items-end text-xs text-muted-foreground sm:ml-auto">
          <span>Sorted by newest</span>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/learning/learning.types.ts
================================================
/**
 * Type definitions for the Learning view
 * Learning allows users to browse all tutorials and articles with filtering and pagination
 */

import type { DifficultyLevel } from "../../types";
import type { ContentCardItemVM } from "../content/content.types";

/**
 * Type filter for Learning view
 * "all" = both tutorials and articles (aggregated)
 * "tutorials" = only tutorials
 * "articles" = only articles
 */
export type LearningTypeFilter = "all" | "tutorials" | "articles";

/**
 * Level filter for Learning view
 * "ALL" is a UI-only sentinel that means no level filter (do not send to API)
 * Otherwise, must be a valid DifficultyLevel
 */
export type LearningLevelFilter = DifficultyLevel | "ALL";

/**
 * Error view model for Learning feed
 * Categorizes errors for appropriate user messaging
 */
export interface LearningFeedErrorVM {
  kind: "network" | "http" | "unknown";
  status?: number;
  message: string;
  api?: {
    error: {
      code: string;
      message: string;
      details?: Record<string, string>;
    };
  };
}

/**
 * Pagination view model for Learning
 * Supports deterministic pagination with combined totals for aggregated mode
 */
export interface LearningPaginationVM {
  page: number; // current page (>=1)
  totalPages: number; // computed (>=1 for display; may be 0 internally when totalItems=0)
  totalItems: number;
  pageSize: number; // 10 for aggregated; 10 for single-type (kept explicit)
}

/**
 * Complete state view model for Learning feed
 * Encapsulates all state needed to render the Learning view
 */
export interface LearningFeedStateVM {
  isAuthenticated: boolean;
  userSelectedLevel?: DifficultyLevel;

  type: LearningTypeFilter;
  level: LearningLevelFilter;

  items: ContentCardItemVM[];
  pagination: LearningPaginationVM;

  isLoading: boolean;
  error: LearningFeedErrorVM | null;
}



================================================
FILE: src/components/learning/LearningView.tsx
================================================
/**
 * LearningView - Main container for the Learning page
 * Allows users to browse all tutorials and articles with filtering and pagination
 */

import { useId } from "react";
import type { DifficultyLevel } from "../../types";
import type { LearningTypeFilter, LearningLevelFilter } from "./learning.types";
import { useLearningFeed } from "../hooks/useLearningFeed";
import { SectionHeader } from "../shared/SectionHeader";
import { LoadingState } from "../shared/LoadingState";
import { FullPageError } from "../shared/FullPageError";
import { EmptyState } from "../shared/EmptyState";
import { ContentCard } from "../content/ContentCard";
import { PaginationControls } from "../shared/PaginationControls";
import { FiltersBar } from "./FiltersBar";

interface LearningViewProps {
  isAuthenticated: boolean;
  userSelectedLevel?: DifficultyLevel;
  initialLevelFilter: LearningLevelFilter;
  initialTypeFilter?: LearningTypeFilter;
}

export default function LearningView({
  isAuthenticated,
  userSelectedLevel,
  initialLevelFilter,
  initialTypeFilter = "all",
}: LearningViewProps) {
  const headingId = useId();

  const {
    type,
    level,
    items,
    pagination,
    isLoading,
    error,
    setType,
    setLevel,
    goPrev,
    goNext,
    retry,
  } = useLearningFeed({
    isAuthenticated,
    userSelectedLevel,
    initialLevelFilter,
    initialTypeFilter,
  });

  return (
    <section aria-labelledby={headingId} className="w-full">
      {/* Header */}
      <SectionHeader
        id={headingId}
        title="Learning"
        description="Browse all tutorials and articles. Filter by type and level to find content that matches your learning goals."
      />

      {/* Filters */}
      <div className="mb-6">
        <FiltersBar
          type={type}
          level={level}
          userSelectedLevel={userSelectedLevel}
          onTypeChange={setType}
          onLevelChange={setLevel}
        />
      </div>

      {/* Results area */}
      <div className="mb-6">
        {isLoading && <LoadingState count={10} />}

        {!isLoading && error && (
          <FullPageError
            title="Failed to load content"
            message={error.message}
            onRetry={retry}
          />
        )}

        {!isLoading && !error && items.length === 0 && (
          <EmptyState
            title="No content found"
            description="Try a different type or level, or check back later for new content."
          />
        )}

        {!isLoading && !error && items.length > 0 && (
          <ul role="list" className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {items.map((item) => (
              <ContentCard key={`${item.type}-${item.id}`} item={item} />
            ))}
          </ul>
        )}
      </div>

      {/* Pagination - only show when there are items or totalItems > 0 */}
      {!isLoading && !error && pagination.totalItems > 0 && (
        <PaginationControls
          currentPage={pagination.page}
          totalPages={pagination.totalPages}
          isLoading={isLoading}
          onPrev={goPrev}
          onNext={goNext}
        />
      )}
    </section>
  );
}



================================================
FILE: src/components/learning/LevelFilter.tsx
================================================
/**
 * LevelFilter - Select control for difficulty level filtering
 * Defaults to user's selected level when authenticated, or "All" when anonymous
 * Shows warning when browsing other levels (not recommended)
 */

import type { DifficultyLevel } from "../../types";
import type { LearningLevelFilter } from "./learning.types";

interface LevelFilterProps {
  value: LearningLevelFilter;
  userSelectedLevel?: DifficultyLevel;
  onChange: (next: LearningLevelFilter) => void;
}

/**
 * Format level for display
 */
function formatLevel(level: string): string {
  if (level === "ALL") return "All";
  return level.charAt(0) + level.slice(1).toLowerCase();
}

export function LevelFilter({ value, userSelectedLevel, onChange }: LevelFilterProps) {
  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    onChange(event.target.value as LearningLevelFilter);
  };

  // Show warning when browsing other levels (not recommended)
  const showWarning =
    value !== "ALL" && userSelectedLevel && value !== userSelectedLevel;

  return (
    <div className="flex flex-col gap-1.5">
      <label htmlFor="learning-level" className="text-sm font-medium text-foreground">
        Level
      </label>
      <select
        id="learning-level"
        value={value}
        onChange={handleChange}
        className="h-10 rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
      >
        <option value="ALL">All</option>
        <option value="BEGINNER">Beginner</option>
        <option value="INTERMEDIATE">Intermediate</option>
        <option value="EXPERIENCED">Experienced</option>
      </select>
      {showWarning && (
        <p className="text-xs text-amber-600 dark:text-amber-400">
          Browsing other levels (not recommended)
        </p>
      )}
    </div>
  );
}



================================================
FILE: src/components/learning/TypeFilter.tsx
================================================
/**
 * TypeFilter - Select control for content type filtering
 * Allows users to filter by All, Tutorials, or Articles
 */

import type { LearningTypeFilter } from "./learning.types";

interface TypeFilterProps {
  value: LearningTypeFilter;
  onChange: (next: LearningTypeFilter) => void;
}

export function TypeFilter({ value, onChange }: TypeFilterProps) {
  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    onChange(event.target.value as LearningTypeFilter);
  };

  return (
    <div className="flex flex-col gap-1.5">
      <label htmlFor="learning-type" className="text-sm font-medium text-foreground">
        Type
      </label>
      <select
        id="learning-type"
        value={value}
        onChange={handleChange}
        className="h-10 rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2"
      >
        <option value="all">All</option>
        <option value="tutorials">Tutorials</option>
        <option value="articles">Articles</option>
      </select>
    </div>
  );
}



================================================
FILE: src/components/nav/Navbar.astro
================================================
---
/**
 * Primary navigation bar for Cook Mastery
 * Shows main navigation links and authentication controls
 * Displays different navigation based on authentication status
 */

// Get user and profile from middleware-populated locals
const { user, profile } = Astro.locals;
const isAuthenticated = !!user && !!profile;
---

<nav aria-label="Primary" class="border-b bg-background">
  <div class="mx-auto flex h-16 max-w-7xl items-center justify-between px-4">
    {/* Brand */}
    <div class="flex items-center gap-8">
      <a href="/" class="text-xl font-bold text-foreground hover:text-foreground/80">
        Cook Mastery
      </a>
      
      {/* Primary Navigation Links */}
      <div class="hidden md:flex md:gap-6">
        <a 
          href="/" 
          class="text-sm font-medium text-muted-foreground hover:text-foreground transition-colors"
          aria-current={Astro.url.pathname === "/" ? "page" : undefined}
        >
          Home
        </a>
        <a 
          href="/learning" 
          class="text-sm font-medium text-muted-foreground hover:text-foreground transition-colors"
          aria-current={Astro.url.pathname.startsWith("/learning") ? "page" : undefined}
        >
          Learning
        </a>
        {/* Only show Cookbook for authenticated users */}
        {isAuthenticated && (
          <a 
            href="/cookbook" 
            class="text-sm font-medium text-muted-foreground hover:text-foreground transition-colors"
            aria-current={Astro.url.pathname.startsWith("/cookbook") ? "page" : undefined}
          >
            Cookbook
          </a>
        )}
        {/* Only show Profile for authenticated users */}
        {isAuthenticated && (
          <a 
            href="/profile" 
            class="text-sm font-medium text-muted-foreground hover:text-foreground transition-colors"
            aria-current={Astro.url.pathname.startsWith("/profile") ? "page" : undefined}
          >
            Profile
          </a>
        )}
      </div>
    </div>

    {/* Authentication Controls (right side) */}
    <div class="flex items-center gap-4">
      {isAuthenticated ? (
        <>
          {/* Display username */}
          <span class="text-sm font-medium text-foreground">
            {profile.username}
          </span>
          
          {/* Logout form */}
          <form method="POST" action="/api/auth/logout">
            <button 
              type="submit"
              class="rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 transition-colors"
            >
              Log out
            </button>
          </form>
        </>
      ) : (
        <>
          {/* Login and Sign up links for unauthenticated users */}
          <a 
            href="/login" 
            class="text-sm font-medium text-muted-foreground hover:text-foreground transition-colors"
          >
            Log in
          </a>
          <a 
            href="/signup" 
            class="rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 transition-colors"
          >
            Sign up
          </a>
        </>
      )}
    </div>
  </div>
</nav>



================================================
FILE: src/components/profile/profile.types.ts
================================================
/**
 * Type definitions for Profile view components
 * View-scoped ViewModels for rendering logic
 */

import type { DifficultyLevel } from '../../types';

/**
 * View model for level settings card
 */
export interface ProfileLevelSettingsVM {
  savedLevel: DifficultyLevel;
  draftLevel: DifficultyLevel;
  isDirty: boolean;
  helperText: string;
}

/**
 * View model for save state
 */
export interface ProfileSaveStateVM {
  isSaving: boolean;
  error: string | null;
}

/**
 * View model for progress panel display
 */
export interface ProfileProgressVM {
  selectedLevel: DifficultyLevel;
  completionPercent: number; // 0-100
  isUpToDate: boolean; // >= 85%
  isEligibleToAdvance: boolean; // >= 85% AND not EXPERIENCED
  totalCount: number;
  completedCount: number;
  emptyState: boolean; // totalCount === 0
}

/**
 * View model for logout state
 */
export interface ProfileLogoutStateVM {
  isLoggingOut: boolean;
  error: string | null;
}



================================================
FILE: src/components/profile/ProfileView.tsx
================================================
import { useState, useCallback, useEffect } from 'react';
import { toast } from 'sonner';
import { Button } from '../ui/button';
import { LevelSelector } from '../auth/LevelSelector';
import { ProgressPanel } from './ProgressPanel';
import { useUserProgress } from './useUserProgress';
import type { ProfileDTO, DifficultyLevel, UpdateProfileCommand, ApiErrorResponse } from '../../types';

interface ProfileViewProps {
  user: {
    id: string;
    email: string;
  };
  profile: ProfileDTO;
  enableProgress?: boolean;
}

/**
 * ProfileView component
 * Displays user profile information, level settings, and logout functionality
 */
export default function ProfileView({ user, profile, enableProgress = true }: ProfileViewProps) {
  // Logout state
  const [isLoggingOut, setIsLoggingOut] = useState(false);
  const [logoutError, setLogoutError] = useState<string | null>(null);

  // Level settings state
  const [savedLevel, setSavedLevel] = useState<DifficultyLevel>(profile.selected_level);
  const [draftLevel, setDraftLevel] = useState<DifficultyLevel>(profile.selected_level);
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);

  // Derived state
  const isDirty = draftLevel !== savedLevel;

  // Progress tracking state
  const {
    data: progressData,
    isLoading: isLoadingProgress,
    error: progressError,
    retry: retryProgress,
  } = useUserProgress({ enabled: enableProgress });

  /**
   * Handle level selection change
   */
  const handleLevelChange = useCallback((level: DifficultyLevel) => {
    setDraftLevel(level);
    setSaveError(null); // Clear any existing errors
  }, []);

  /**
   * Handle save level action
   * Calls PATCH /api/profile and updates local state on success
   */
  const handleSaveLevel = useCallback(async () => {
    // Guard: should not happen due to disabled state, but defensive check
    if (!isDirty || isSaving) {
      return;
    }

    setSaveError(null);
    setIsSaving(true);

    try {
      const command: UpdateProfileCommand = {
        selected_level: draftLevel,
      };

      const response = await fetch('/api/profile', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(command),
      });

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      // Handle validation errors (400)
      if (response.status === 400) {
        const errorData = (await response.json()) as ApiErrorResponse;
        
        // Check for field-specific error
        if (errorData.error.details?.selected_level) {
          setSaveError(errorData.error.details.selected_level);
        } else if (errorData.error.details?.general) {
          setSaveError(errorData.error.details.general);
        } else {
          setSaveError(errorData.error.message);
        }
        return;
      }

      // Handle other client/server errors with toast
      if (!response.ok) {
        const errorData = (await response.json()) as ApiErrorResponse;
        
        // Rate limit or server errors get toast
        if (response.status === 429) {
          toast.error('Too many requests. Please try again in a moment.');
        } else {
          toast.error(errorData.error.message || 'Failed to update level');
        }
        return;
      }

      // Success - update local state
      const updatedProfile = (await response.json()) as ProfileDTO;
      setSavedLevel(updatedProfile.selected_level);
      setDraftLevel(updatedProfile.selected_level);
      setSaveError(null);
      toast.success('Level updated');
    } catch (err) {
      // Network error
      toast.error("Couldn't update level. Check your connection.");
    } finally {
      setIsSaving(false);
    }
  }, [draftLevel, isDirty, isSaving]);

  /**
   * Handle logout action
   * Calls the logout API endpoint and redirects to login on success
   */
  const handleLogout = useCallback(async () => {
    // Reset error state
    setLogoutError(null);
    setIsLoggingOut(true);

    try {
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error?.message || 'Failed to log out');
      }

      // Redirect to login page on successful logout
      window.location.href = '/login';
    } catch (err) {
      setLogoutError(err instanceof Error ? err.message : 'An unexpected error occurred');
      setIsLoggingOut(false);
    }
  }, []);

  // Format the difficulty level for display
  const formatLevel = (level: string): string => {
    return level.charAt(0) + level.slice(1).toLowerCase();
  };

  // Client-side date formatting state
  const [formattedDate, setFormattedDate] = useState<string>('');

  // Format date on client-side to avoid hydration mismatch
  useEffect(() => {
    setFormattedDate(
      new Date(profile.created_at).toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    );
  }, [profile.created_at]);

  return (
    <div className="mx-auto max-w-2xl">
      <h1 className="mb-8 text-3xl font-bold">Profile</h1>

      <div className="space-y-6">
        {/* Profile Information Card */}
        <div className="rounded-lg border bg-card p-6 shadow-sm">
          <h2 className="mb-4 text-xl font-semibold">Account Information</h2>
          
          <div className="space-y-4">
            <div>
              <p className="text-sm font-medium text-muted-foreground">Username</p>
              <p className="text-base">{profile.username}</p>
            </div>

            <div>
              <p className="text-sm font-medium text-muted-foreground">Email</p>
              <p className="text-base">{user.email}</p>
            </div>

            <div>
              <p className="text-sm font-medium text-muted-foreground">Current Level</p>
              <p className="text-base">{formatLevel(savedLevel)}</p>
            </div>

            <div>
              <p className="text-sm font-medium text-muted-foreground">Member Since</p>
              <p className="text-base">{formattedDate}</p>
            </div>
          </div>
        </div>

        {/* Progress Panel */}
        {enableProgress && (
          <ProgressPanel
            isLoading={isLoadingProgress}
            error={progressError || undefined}
            progress={progressData || undefined}
            onRetry={retryProgress}
          />
        )}

        {/* Level Settings Card */}
        <div className="rounded-lg border bg-card p-6 shadow-sm">
          <h2 className="mb-4 text-xl font-semibold">Learning Level</h2>
          
          <div className="space-y-4">
            <p className="text-sm text-muted-foreground">
              Changing your level will change recommendations on the home page.
            </p>

            {/* Level Selector */}
            <LevelSelector
              value={draftLevel}
              onChange={handleLevelChange}
              disabled={isSaving}
              error={saveError || undefined}
            />

            {/* Inline error display */}
            {saveError && (
              <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                {saveError}
              </div>
            )}

            {/* Save button */}
            <Button
              onClick={handleSaveLevel}
              disabled={!isDirty || isSaving}
              className="w-full sm:w-auto"
            >
              {isSaving ? 'Saving...' : 'Save level'}
            </Button>
          </div>
        </div>

        {/* Logout Section */}
        <div className="rounded-lg border bg-card p-6 shadow-sm">
          <h2 className="mb-4 text-xl font-semibold">Session</h2>
          
          <div className="space-y-4">
            <p className="text-sm text-muted-foreground">
              Log out of your account to end your current session.
            </p>

            {logoutError && (
              <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                {logoutError}
              </div>
            )}

            <Button
              variant="destructive"
              onClick={handleLogout}
              disabled={isLoggingOut}
              className="w-full sm:w-auto"
            >
              {isLoggingOut ? 'Logging out...' : 'Log out'}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/profile/ProgressPanel.tsx
================================================
/**
 * ProgressPanel component
 * Displays user progress for the currently selected learning level
 */

import { Button } from '../ui/button';
import type { ProfileProgressVM } from './profile.types';

interface ProgressPanelProps {
  isLoading: boolean;
  error?: string;
  progress?: ProfileProgressVM;
  onRetry?(): void;
}

/**
 * Format level for display
 */
function formatLevel(level: string): string {
  return level.charAt(0) + level.slice(1).toLowerCase();
}

/**
 * ProgressPanel component
 * Shows completion percentage, status, and advancement eligibility
 */
export function ProgressPanel({ isLoading, error, progress, onRetry }: ProgressPanelProps) {
  return (
    <div className="rounded-lg border bg-card p-6 shadow-sm">
      <h2 className="mb-4 text-xl font-semibold">Progress</h2>

      {/* Loading state */}
      {isLoading && (
        <div className="space-y-3">
          <div className="h-4 w-3/4 animate-pulse rounded bg-muted"></div>
          <div className="h-4 w-1/2 animate-pulse rounded bg-muted"></div>
        </div>
      )}

      {/* Error state */}
      {!isLoading && error && (
        <div className="space-y-4">
          <div className="rounded-md bg-destructive/10 p-3 text-sm text-destructive">
            {error}
          </div>
          {onRetry && (
            <Button variant="outline" size="sm" onClick={onRetry}>
              Retry
            </Button>
          )}
        </div>
      )}

      {/* Success state with data */}
      {!isLoading && !error && progress && (
        <div className="space-y-4">
          {/* Empty state - no content at this level */}
          {progress.emptyState ? (
            <div className="text-sm text-muted-foreground">
              <p>No content available for {formatLevel(progress.selectedLevel)} level yet.</p>
              <p className="mt-2">
                Progress tracking will appear here once content is added to this level.
              </p>
            </div>
          ) : (
            <>
              {/* Completion percentage */}
              <div>
                <p className="text-sm font-medium text-muted-foreground">
                  {formatLevel(progress.selectedLevel)} Level Completion
                </p>
                <div className="mt-2 flex items-baseline gap-2">
                  <p className="text-3xl font-bold">{Math.round(progress.completionPercent)}%</p>
                  <p className="text-sm text-muted-foreground">
                    ({progress.completedCount} of {progress.totalCount})
                  </p>
                </div>
              </div>

              {/* Progress bar */}
              <div className="h-2 w-full overflow-hidden rounded-full bg-muted">
                <div
                  className="h-full bg-primary transition-all duration-300"
                  style={{ width: `${Math.min(progress.completionPercent, 100)}%` }}
                />
              </div>

              {/* Status indicator */}
              <div className="flex items-center gap-2">
                <p className="text-sm font-medium text-muted-foreground">Status:</p>
                <span
                  className={`inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium ${
                    progress.isUpToDate
                      ? 'bg-green-100 text-green-800'
                      : 'bg-yellow-100 text-yellow-800'
                  }`}
                >
                  {progress.isUpToDate ? 'Up to date' : 'Out of date'}
                </span>
              </div>

              {/* Eligibility to advance */}
              <div className="rounded-md border border-border bg-muted/30 p-3">
                <p className="text-sm font-medium">Advancement Eligibility</p>
                <p className="mt-1 text-sm text-muted-foreground">
                  {progress.isEligibleToAdvance ? (
                    <>
                      <span className="font-medium text-foreground">Eligible to advance!</span> You
                      can consider moving to the next level.
                    </>
                  ) : progress.selectedLevel === 'EXPERIENCED' ? (
                    <>You&apos;re already at the highest level.</>
                  ) : (
                    <>
                      Complete at least 85% of content at this level to become eligible for
                      advancement.
                    </>
                  )}
                </p>
              </div>
            </>
          )}
        </div>
      )}
    </div>
  );
}



================================================
FILE: src/components/profile/useUserProgress.ts
================================================
/**
 * Custom hook for fetching user progress summary
 */

import { useState, useEffect, useCallback } from 'react';
import type { UserProgressSummaryDTO, DifficultyLevel, ApiErrorResponse } from '../../types';
import type { ProfileProgressVM } from './profile.types';

interface UseUserProgressOptions {
  enabled?: boolean;
  initialData?: UserProgressSummaryDTO;
}

interface UseUserProgressResult {
  data: ProfileProgressVM | null;
  isLoading: boolean;
  error: string | null;
  retry(): void;
}

/**
 * Transform UserProgressSummaryDTO to ProfileProgressVM for the selected level
 */
function transformToProgressVM(
  summary: UserProgressSummaryDTO
): ProfileProgressVM | null {
  // Find progress for the selected level
  const levelProgress = summary.level_progress.find(
    (lp) => lp.level === summary.selected_level
  );

  if (!levelProgress) {
    return null;
  }

  return {
    selectedLevel: summary.selected_level,
    completionPercent: levelProgress.completion_percent,
    isUpToDate: levelProgress.is_up_to_date,
    isEligibleToAdvance: summary.can_advance,
    totalCount: levelProgress.total_count,
    completedCount: levelProgress.completed_count,
    emptyState: levelProgress.total_count === 0,
  };
}

/**
 * Hook to fetch and manage user progress summary
 * 
 * @param options - Configuration options
 * @returns Progress data, loading state, error state, and retry function
 */
export function useUserProgress(
  options: UseUserProgressOptions = {}
): UseUserProgressResult {
  const { enabled = true, initialData } = options;

  const [data, setData] = useState<ProfileProgressVM | null>(
    initialData ? transformToProgressVM(initialData) : null
  );
  const [isLoading, setIsLoading] = useState(!initialData && enabled);
  const [error, setError] = useState<string | null>(null);
  const [refetchTrigger, setRefetchTrigger] = useState(0);

  const fetchProgress = useCallback(async () => {
    // Skip if disabled
    if (!enabled) {
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/progress/summary');

      // Handle 401 - session expired
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      // Handle other errors
      if (!response.ok) {
        const errorData = (await response.json()) as ApiErrorResponse;
        setError(errorData.error.message || 'Failed to load progress');
        return;
      }

      // Success - transform and set data
      const summary = (await response.json()) as UserProgressSummaryDTO;
      const progressVM = transformToProgressVM(summary);
      setData(progressVM);
    } catch (err) {
      // Network error
      setError("Couldn't load progress. Check your connection.");
    } finally {
      setIsLoading(false);
    }
  }, [enabled]);

  // Fetch on mount and when refetch is triggered
  useEffect(() => {
    fetchProgress();
  }, [fetchProgress, refetchTrigger]);

  // Retry function
  const retry = useCallback(() => {
    setRefetchTrigger((prev) => prev + 1);
  }, []);

  return {
    data,
    isLoading,
    error,
    retry,
  };
}



================================================
FILE: src/components/shared/EmptyState.tsx
================================================
/**
 * EmptyState - Friendly empty state message
 * Shown when a section has no items to display
 */

interface EmptyStateProps {
  title: string;
  description?: string;
}

export function EmptyState({ title, description }: EmptyStateProps) {
  return (
    <div
      role="status"
      className="flex flex-col items-center justify-center rounded-lg border border-dashed bg-muted/20 px-6 py-12 text-center"
    >
      <h3 className="text-lg font-semibold text-foreground">{title}</h3>
      {description && (
        <p className="mt-2 text-sm text-muted-foreground">{description}</p>
      )}
    </div>
  );
}



================================================
FILE: src/components/shared/FullPageError.tsx
================================================
/**
 * FullPageError - Error state with retry button
 * Used when content fails to load from the API
 */

import { Button } from "../ui/button";

interface FullPageErrorProps {
  title?: string;
  message: string;
  onRetry: () => void;
}

export function FullPageError({
  title = "Something went wrong",
  message,
  onRetry,
}: FullPageErrorProps) {
  return (
    <div
      role="alert"
      className="flex flex-col items-center justify-center rounded-lg border border-destructive/20 bg-destructive/5 px-6 py-12 text-center"
    >
      <h3 className="text-lg font-semibold text-foreground">{title}</h3>
      <p className="mt-2 text-sm text-muted-foreground">{message}</p>
      <Button
        onClick={onRetry}
        variant="outline"
        className="mt-4"
        aria-label="Retry loading content"
      >
        Try again
      </Button>
    </div>
  );
}



================================================
FILE: src/components/shared/LoadingState.tsx
================================================
/**
 * LoadingState - Skeleton loading state for content lists
 * Shows placeholder cards while data is being fetched
 */

interface LoadingStateProps {
  count?: number;
}

export function LoadingState({ count = 5 }: LoadingStateProps) {
  return (
    <div 
      aria-busy="true" 
      aria-live="polite" 
      className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3"
      suppressHydrationWarning
    >
      {Array.from({ length: count }).map((_, index) => (
        <div
          key={index}
          className="animate-pulse rounded-lg border bg-card p-4"
          role="status"
          aria-label="Loading content"
          suppressHydrationWarning
        >
          {/* Badge skeleton */}
          <div className="mb-3 h-5 w-20 rounded bg-muted" suppressHydrationWarning />
          
          {/* Title skeleton */}
          <div className="mb-2 h-6 w-3/4 rounded bg-muted" suppressHydrationWarning />
          
          {/* Summary skeleton */}
          <div className="mb-1 h-4 w-full rounded bg-muted" suppressHydrationWarning />
          <div className="mb-3 h-4 w-5/6 rounded bg-muted" suppressHydrationWarning />
          
          {/* Metadata skeleton */}
          <div className="flex items-center gap-2" suppressHydrationWarning>
            <div className="h-4 w-24 rounded bg-muted" suppressHydrationWarning />
            <div className="h-4 w-16 rounded bg-muted" suppressHydrationWarning />
          </div>
        </div>
      ))}
    </div>
  );
}



================================================
FILE: src/components/shared/NotFoundState.tsx
================================================
/**
 * NotFoundState - Standardized not-found UI for detail pages
 * Used when a specific resource (tutorial, article, etc.) cannot be found
 */

import { Button } from "../ui/button";

interface NotFoundStateProps {
  title?: string;
  description?: string;
  backHref?: string;
  backLabel?: string;
}

export function NotFoundState({
  title = "Content not found",
  description = "The content you're looking for doesn't exist or may have been removed.",
  backHref = "/learning",
  backLabel = "Back to Learning",
}: NotFoundStateProps) {
  return (
    <div
      role="status"
      className="flex flex-col items-center justify-center rounded-lg border border-border bg-card px-6 py-12 text-center"
    >
      <div className="mb-4 text-6xl" aria-hidden="true">
        🔍
      </div>
      <h2 className="text-xl font-semibold text-foreground">{title}</h2>
      <p className="mt-2 text-sm text-muted-foreground">{description}</p>
      <Button asChild variant="default" className="mt-6">
        <a href={backHref}>{backLabel}</a>
      </Button>
    </div>
  );
}



================================================
FILE: src/components/shared/PaginationControls.tsx
================================================
/**
 * PaginationControls - Shared pagination component
 * Displays Prev/Next buttons and "Page X of Y" indicator
 * Handles disabled states when at bounds or while loading
 */

import { Button } from "../ui/button";

interface PaginationControlsProps {
  currentPage: number;
  totalPages: number;
  isLoading?: boolean;
  onPrev: () => void;
  onNext: () => void;
}

export function PaginationControls({
  currentPage,
  totalPages,
  isLoading = false,
  onPrev,
  onNext,
}: PaginationControlsProps) {
  // Don't render if there's only one page or no pages
  if (totalPages <= 1) {
    return null;
  }

  const isPrevDisabled = isLoading || currentPage <= 1;
  const isNextDisabled = isLoading || currentPage >= totalPages;

  return (
    <nav aria-label="Pagination" className="flex items-center justify-center gap-4">
      {/* Previous button */}
      <Button
        variant="outline"
        onClick={onPrev}
        disabled={isPrevDisabled}
        aria-label="Go to previous page"
      >
        Previous
      </Button>

      {/* Page indicator */}
      <span className="text-sm text-muted-foreground" aria-live="polite" aria-atomic="true">
        Page {currentPage} of {totalPages}
      </span>

      {/* Next button */}
      <Button
        variant="outline"
        onClick={onNext}
        disabled={isNextDisabled}
        aria-label="Go to next page"
      >
        Next
      </Button>
    </nav>
  );
}



================================================
FILE: src/components/shared/SectionHeader.tsx
================================================
/**
 * SectionHeader - Displays section title and description
 * Used for both Tutorials and Articles sections on Home
 */

interface SectionHeaderProps {
  id: string;
  title: string;
  description: string;
}

export function SectionHeader({ id, title, description }: SectionHeaderProps) {
  return (
    <div className="mb-6" suppressHydrationWarning>
      <h2 id={id} className="text-2xl font-bold tracking-tight text-foreground">
        {title}
      </h2>
      <p className="mt-2 text-sm text-muted-foreground">{description}</p>
    </div>
  );
}



================================================
FILE: src/components/shared/ToastHost.tsx
================================================
/**
 * ToastHost - Global toast container for transient notifications
 * Provides a single toast system (sonner) mounted once in the layout
 * Views can trigger toasts for success states and transient errors
 */

import { Toaster } from "../ui/sonner";

export function ToastHost() {
  return <Toaster position="top-center" />;
}



================================================
FILE: src/components/tutorial-detail/CompletionCallToAction.tsx
================================================
/**
 * CompletionCallToAction - Interactive CTA for marking tutorial as passed
 * Authenticated-only component with idempotent behavior
 * Shows completion status and allows one-time marking as passed
 */

import { useState, useCallback } from "react";
import { toast } from "sonner";
import { Button } from "../ui/button";
import type {
  CompletionCallToActionProps,
  CompletionCTAStateVM,
} from "./tutorial-detail.types";
import type { CompleteTutorialResponseDTO, ApiErrorResponse } from "../../types";

export function CompletionCallToAction({
  tutorialId,
  isCompleted,
  completedAt,
  onCompleted,
}: CompletionCallToActionProps) {
  // Local state for submission
  const [state, setState] = useState<CompletionCTAStateVM>({
    isSubmitting: false,
    error: null,
  });

  /**
   * Format completion date for display
   */
  const formatCompletedDate = (isoDate: string): string => {
    const date = new Date(isoDate);
    return date.toLocaleDateString(undefined, {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
  };

  /**
   * Handle mark as passed action
   */
  const handleMarkPassed = useCallback(async () => {
    // Guard: Already completed
    if (isCompleted) {
      return;
    }

    setState({ isSubmitting: true, error: null });

    try {
      const response = await fetch(`/api/tutorials/${tutorialId}/complete`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });

      // Handle non-OK responses
      if (!response.ok) {
        // 401 Unauthorized - redirect to login
        if (response.status === 401) {
          window.location.href = "/login";
          return;
        }

        // 404 Not Found - tutorial no longer exists
        if (response.status === 404) {
          setState({
            isSubmitting: false,
            error: "This tutorial no longer exists.",
          });
          return;
        }

        // 429 Rate Limit or 500 Server Error - show toast and keep button enabled
        if (response.status === 429 || response.status >= 500) {
          const errorMessage =
            response.status === 429
              ? "Too many requests. Please try again in a moment."
              : "Something went wrong. Please try again.";

          setState({
            isSubmitting: false,
            error: errorMessage,
          });

          // Show toast for transient errors
          toast.error(errorMessage);
          return;
        }

        // Other errors - parse API response
        try {
          const errorData = (await response.json()) as ApiErrorResponse;
          setState({
            isSubmitting: false,
            error: errorData.error.message,
          });
        } catch {
          setState({
            isSubmitting: false,
            error: "An unexpected error occurred.",
          });
        }
        return;
      }

      // Success - parse response
      const data = (await response.json()) as CompleteTutorialResponseDTO;

      // Update parent state via callback
      onCompleted(data.completed_at);

      // Clear local error state
      setState({ isSubmitting: false, error: null });

      // Show success toast (optional but recommended)
      toast.success("Marked as passed");
    } catch (err) {
      // Network error
      const errorMessage = "Network error. Please check your connection.";
      setState({
        isSubmitting: false,
        error: errorMessage,
      });
      toast.error(errorMessage);
    }
  }, [tutorialId, isCompleted, onCompleted]);

  return (
    <section
      aria-label="Completion"
      className="mt-8 space-y-4 rounded-lg border border-border bg-card p-6"
    >
      {/* Status callout */}
      {isCompleted ? (
        // Completed state
        <div className="flex items-center gap-2 text-green-600 dark:text-green-400">
          <svg
            className="h-5 w-5"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M5 13l4 4L19 7"
            />
          </svg>
          <div>
            <p className="font-semibold">Passed</p>
            {completedAt && (
              <p className="text-sm text-muted-foreground">
                Completed on {formatCompletedDate(completedAt)}
              </p>
            )}
          </div>
        </div>
      ) : (
        // Not completed state
        <div className="space-y-2">
          <p className="text-sm text-foreground">
            Ready to practice? Mark this tutorial as passed once you've completed it.
          </p>
        </div>
      )}

      {/* Primary action button */}
      <div className="space-y-3">
        <Button
          onClick={handleMarkPassed}
          disabled={state.isSubmitting || isCompleted}
          className="w-full sm:w-auto"
          aria-label={isCompleted ? "Already marked as passed" : "Mark as passed"}
        >
          {state.isSubmitting
            ? "Marking..."
            : isCompleted
              ? "Passed"
              : "Mark as passed"}
        </Button>

        {/* Inline error message */}
        {state.error && (
          <div
            role="alert"
            className="rounded-md border border-destructive/20 bg-destructive/10 px-4 py-3 text-sm text-destructive"
          >
            {state.error}
          </div>
        )}
      </div>
    </section>
  );
}



================================================
FILE: src/components/tutorial-detail/ContentHeader.tsx
================================================
/**
 * ContentHeader - Tutorial header with type badge, title, and metadata
 * Displays tutorial identity and key metadata in a structured format
 */

import type { ContentHeaderProps } from "./tutorial-detail.types";

interface ContentHeaderPropsExtended extends ContentHeaderProps {
  headingId?: string;
}

export function ContentHeader({ header, headingId }: ContentHeaderPropsExtended) {
  return (
    <header className="space-y-4">
      {/* Type badge */}
      <div>
        <span className="inline-flex items-center rounded-full bg-blue-100 px-3 py-1 text-sm font-medium text-blue-800 dark:bg-blue-900 dark:text-blue-200">
          Tutorial
        </span>
      </div>

      {/* Title */}
      <h1 id={headingId} className="text-3xl font-bold text-foreground sm:text-4xl">
        {header.title}
      </h1>

      {/* Metadata row */}
      <dl className="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm text-muted-foreground">
        {/* Level */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Level</dt>
          <dd className="font-medium">{header.levelLabel}</dd>
        </div>

        <span aria-hidden="true">•</span>

        {/* Difficulty */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Difficulty</dt>
          <dd>{header.difficultyLabel}</dd>
        </div>

        <span aria-hidden="true">•</span>

        {/* Category */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Category</dt>
          <dd>{header.categoryLabel}</dd>
        </div>

        <span aria-hidden="true">•</span>

        {/* Created date */}
        <div className="flex items-center gap-1.5">
          <dt className="sr-only">Published</dt>
          <dd>
            <time dateTime={header.createdAtLabel}>{header.createdAtLabel}</time>
          </dd>
        </div>
      </dl>
    </header>
  );
}



================================================
FILE: src/components/tutorial-detail/ContentSections.tsx
================================================
/**
 * ContentSections - Structured tutorial content sections
 * Renders all tutorial sections in the required order:
 * 1. Summary
 * 2. Content
 * 3. Steps/sections
 * 4. Practice recommendations
 * 5. Key takeaways
 */

import { useId } from "react";
import type { ContentSectionsProps } from "./tutorial-detail.types";

export function ContentSections({ sections }: ContentSectionsProps) {
  const summaryId = useId();
  const contentId = useId();
  const stepsId = useId();
  const practiceId = useId();
  const takeawaysId = useId();

  return (
    <div className="space-y-8">
      {/* Section 1: Summary */}
      <section aria-labelledby={summaryId} className="space-y-3">
        <h2 id={summaryId} className="text-2xl font-semibold text-foreground">
          Summary
        </h2>
        <p className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
          {sections.summary}
        </p>
      </section>

      {/* Section 2: Content */}
      <section aria-labelledby={contentId} className="space-y-3">
        <h2 id={contentId} className="text-2xl font-semibold text-foreground">
          Content
        </h2>
        <div className="prose prose-sm max-w-none dark:prose-invert">
          <p className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
            {sections.content}
          </p>
        </div>
      </section>

      {/* Section 3: Steps */}
      {sections.steps.length > 0 && (
        <section aria-labelledby={stepsId} className="space-y-4">
          <h2 id={stepsId} className="text-2xl font-semibold text-foreground">
            Steps
          </h2>
          <ol className="space-y-6 pl-0">
            {sections.steps.map((step, index) => (
              <li key={step.order} className="relative pl-8">
                {/* Step number badge */}
                <span
                  className="absolute left-0 top-1 flex h-6 w-6 items-center justify-center rounded-full bg-primary text-xs font-bold text-primary-foreground"
                  aria-label={`Step ${index + 1}`}
                >
                  {index + 1}
                </span>
                
                <div className="space-y-2">
                  {/* Step title */}
                  <h3 className="text-lg font-semibold text-foreground">
                    {step.title}
                  </h3>
                  
                  {/* Step content */}
                  <div className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
                    {step.content}
                  </div>
                </div>
              </li>
            ))}
          </ol>
        </section>
      )}

      {/* Empty steps message */}
      {sections.steps.length === 0 && (
        <section aria-labelledby={stepsId} className="space-y-3">
          <h2 id={stepsId} className="text-2xl font-semibold text-foreground">
            Steps
          </h2>
          <p className="text-sm text-muted-foreground">
            No specific steps for this tutorial.
          </p>
        </section>
      )}

      {/* Section 4: Practice Recommendations */}
      <section aria-labelledby={practiceId} className="space-y-3">
        <h2 id={practiceId} className="text-2xl font-semibold text-foreground">
          Practice Recommendations
        </h2>
        <p className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
          {sections.practiceRecommendations}
        </p>
      </section>

      {/* Section 5: Key Takeaways */}
      <section
        aria-labelledby={takeawaysId}
        className="space-y-3 rounded-lg border border-primary/20 bg-primary/5 p-6"
      >
        <h2 id={takeawaysId} className="text-2xl font-semibold text-foreground">
          Key Takeaways
        </h2>
        <div className="whitespace-pre-wrap text-base leading-relaxed text-foreground">
          {sections.keyTakeaways}
        </div>
      </section>
    </div>
  );
}



================================================
FILE: src/components/tutorial-detail/tutorial-detail.types.ts
================================================
/**
 * ViewModel types for Tutorial Detail View
 * These types transform DTOs from the API into presentation-ready data
 */

import type { DifficultyLevel } from "../../types";
import type { ApiErrorResponse } from "../../types";

/**
 * Main view model for tutorial detail
 * Aggregates header, sections, and completion data
 */
export interface TutorialDetailVM {
  id: string;
  header: TutorialHeaderVM;
  sections: TutorialSectionsVM;
  completion?: TutorialCompletionVM; // Only present when authenticated
}

/**
 * Header view model - metadata displayed at the top
 * Labels are pre-formatted for display
 */
export interface TutorialHeaderVM {
  title: string;
  categoryLabel: string; // e.g. "Practical"
  levelLabel: string; // e.g. "Beginner"
  difficultyLabel: string; // e.g. "Difficulty 2/5"
  createdAtLabel: string; // Localized date string
}

/**
 * Content sections view model
 * Contains all tutorial content blocks in display order
 */
export interface TutorialSectionsVM {
  summary: string;
  content: string;
  steps: TutorialStepVM[];
  practiceRecommendations: string;
  keyTakeaways: string;
}

/**
 * Individual tutorial step view model
 * Steps are pre-sorted by order before rendering
 */
export interface TutorialStepVM {
  order: number;
  title: string;
  content: string;
}

/**
 * Completion status view model
 * Only populated for authenticated users
 */
export interface TutorialCompletionVM {
  isCompleted: boolean;
  completedAt: string | null;
}

/**
 * Error view model for tutorial detail fetch failures
 * Provides structured error information for error UI
 */
export interface TutorialDetailErrorVM {
  kind: "http" | "network";
  status?: number; // For http errors
  message: string; // User-facing error message
  api?: ApiErrorResponse; // Original API error response if available
}

/**
 * Completion CTA state view model
 * Tracks submission state and inline errors for the CTA component
 */
export interface CompletionCTAStateVM {
  isSubmitting: boolean;
  error: string | null; // User-facing error message for inline display
}

/**
 * Props for TutorialDetailView component
 */
export interface TutorialDetailViewProps {
  tutorialId: string;
  isAuthenticated: boolean;
  userSelectedLevel?: DifficultyLevel;
}

/**
 * Props for ContentHeader component
 */
export interface ContentHeaderProps {
  header: TutorialHeaderVM;
}

/**
 * Props for ContentSections component
 */
export interface ContentSectionsProps {
  sections: TutorialSectionsVM;
}

/**
 * Props for CompletionCallToAction component
 */
export interface CompletionCallToActionProps {
  tutorialId: string;
  isCompleted: boolean;
  completedAt: string | null;
  onCompleted: (completedAt: string) => void;
}

/**
 * Helper function to check if a string is a valid UUID
 * Used for client-side validation before API calls
 */
export function isUuid(value: string): boolean {
  const uuidRegex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidRegex.test(value);
}

/**
 * Format category enum for display
 * e.g. "PRACTICAL" -> "Practical"
 */
export function formatCategory(category: string): string {
  return category.charAt(0) + category.slice(1).toLowerCase();
}

/**
 * Format difficulty level enum for display
 * e.g. "BEGINNER" -> "Beginner"
 */
export function formatLevel(level: string): string {
  return level.charAt(0) + level.slice(1).toLowerCase();
}

/**
 * Format difficulty weight as label
 * e.g. 2 -> "Difficulty 2/5"
 */
export function formatDifficultyLabel(weight: number): string {
  return `Difficulty ${weight}/5`;
}

/**
 * Format ISO date string to localized date
 * e.g. "2024-01-15T10:30:00Z" -> "Jan 15, 2024" (locale-dependent)
 */
export function formatCreatedAtLabel(isoDate: string): string {
  const date = new Date(isoDate);
  return date.toLocaleDateString(undefined, {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}



================================================
FILE: src/components/tutorial-detail/TutorialDetailSkeleton.tsx
================================================
/**
 * TutorialDetailSkeleton - Loading skeleton for tutorial detail page
 * Shows placeholder content while tutorial data is being fetched
 */

export function TutorialDetailSkeleton() {
  return (
    <div
      className="animate-pulse space-y-8"
      role="status"
      aria-label="Loading tutorial"
      aria-busy="true"
      aria-live="polite"
    >
      {/* Header skeleton */}
      <div className="space-y-4">
        {/* Badge skeleton */}
        <div className="h-6 w-24 rounded-full bg-muted" />
        
        {/* Title skeleton */}
        <div className="h-10 w-3/4 rounded bg-muted" />
        
        {/* Metadata row skeleton */}
        <div className="flex items-center gap-3">
          <div className="h-4 w-20 rounded bg-muted" />
          <div className="h-4 w-24 rounded bg-muted" />
          <div className="h-4 w-20 rounded bg-muted" />
          <div className="h-4 w-28 rounded bg-muted" />
        </div>
      </div>

      {/* Content sections skeleton */}
      <div className="space-y-8">
        {/* Section 1 */}
        <div className="space-y-3">
          <div className="h-7 w-32 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-3/4 rounded bg-muted" />
        </div>

        {/* Section 2 */}
        <div className="space-y-3">
          <div className="h-7 w-28 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-5/6 rounded bg-muted" />
        </div>

        {/* Section 3 */}
        <div className="space-y-3">
          <div className="h-7 w-24 rounded bg-muted" />
          <div className="h-4 w-full rounded bg-muted" />
          <div className="h-4 w-4/5 rounded bg-muted" />
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/tutorial-detail/TutorialDetailView.tsx
================================================
/**
 * TutorialDetailView - Top-level client component for tutorial detail page
 * Handles data fetching, loading/error/success states, and orchestrates child components
 */

import { useId, useCallback, useState } from "react";
import { useTutorialDetail } from "./useTutorialDetail";
import { TutorialDetailSkeleton } from "./TutorialDetailSkeleton";
import { NotFoundState } from "../shared/NotFoundState";
import { FullPageError } from "../shared/FullPageError";
import { ContentHeader } from "./ContentHeader";
import { ContentSections } from "./ContentSections";
import { CompletionCallToAction } from "./CompletionCallToAction";
import type { TutorialDetailViewProps } from "./tutorial-detail.types";

export function TutorialDetailView({
  tutorialId,
  isAuthenticated,
  userSelectedLevel,
}: TutorialDetailViewProps) {
  const headingId = useId();
  
  // Fetch tutorial detail
  const { data, isLoading, error, isNotFound, retry } = useTutorialDetail({
    tutorialId,
    isAuthenticated,
  });

  // Local completion state for optimistic updates
  const [localCompletion, setLocalCompletion] = useState<{
    isCompleted: boolean;
    completedAt: string | null;
  } | null>(null);

  /**
   * Handle completion callback from CTA
   * Updates local state immediately for optimistic UI
   */
  const handleCompleted = useCallback((completedAt: string) => {
    setLocalCompletion({
      isCompleted: true,
      completedAt,
    });
  }, []);

  // Determine current completion state (local override takes precedence)
  const currentCompletion = localCompletion ?? data?.completion;

  // Loading state
  if (isLoading) {
    return (
      <section aria-labelledby={headingId} aria-busy="true">
        <TutorialDetailSkeleton />
      </section>
    );
  }

  // Not found state (404 or invalid UUID)
  if (isNotFound) {
    return (
      <section aria-labelledby={headingId}>
        <NotFoundState
          title="Tutorial not found"
          description="The tutorial you're looking for doesn't exist or may have been removed."
          backHref="/learning"
          backLabel="Back to Learning"
        />
      </section>
    );
  }

  // Error state (500, network, etc.)
  if (error) {
    const errorMessage =
      error.kind === "network"
        ? "Couldn't load tutorial. Check your connection."
        : error.message || "Something went wrong while loading the tutorial.";

    return (
      <section aria-labelledby={headingId}>
        <FullPageError message={errorMessage} onRetry={retry} />
      </section>
    );
  }

  // Guard: data should exist at this point
  if (!data) {
    return (
      <section aria-labelledby={headingId}>
        <FullPageError
          message="Tutorial data is missing."
          onRetry={retry}
        />
      </section>
    );
  }

  // Success state - render tutorial article
  return (
    <section aria-labelledby={headingId}>
      <article className="space-y-8">
        {/* Header: Badge, Title, Metadata */}
        <ContentHeader header={data.header} headingId={headingId} />

        {/* Content Sections */}
        <ContentSections sections={data.sections} />

        {/* Completion CTA (authenticated users only) */}
        {isAuthenticated && currentCompletion && (
          <CompletionCallToAction
            tutorialId={tutorialId}
            isCompleted={currentCompletion.isCompleted}
            completedAt={currentCompletion.completedAt}
            onCompleted={handleCompleted}
          />
        )}
      </article>
    </section>
  );
}



================================================
FILE: src/components/tutorial-detail/useTutorialDetail.ts
================================================
/**
 * Custom hook for fetching and managing tutorial detail data
 * Handles loading states, errors, UUID validation, and DTO-to-VM mapping
 */

import { useState, useEffect, useCallback, useRef } from "react";
import type {
  GetTutorialDetailResponseDTO,
  ApiErrorResponse,
  TutorialStep,
} from "../../types";
import type {
  TutorialDetailVM,
  TutorialDetailErrorVM,
  TutorialHeaderVM,
  TutorialSectionsVM,
  TutorialStepVM,
  TutorialCompletionVM,
} from "./tutorial-detail.types";
import {
  isUuid,
  formatCategory,
  formatLevel,
  formatDifficultyLabel,
  formatCreatedAtLabel,
} from "./tutorial-detail.types";

interface UseTutorialDetailOptions {
  tutorialId: string;
  isAuthenticated: boolean;
}

interface UseTutorialDetailReturn {
  data: TutorialDetailVM | null;
  isLoading: boolean;
  error: TutorialDetailErrorVM | null;
  isNotFound: boolean;
  retry: () => void;
}

/**
 * Parse API error response
 */
async function parseApiError(response: Response): Promise<TutorialDetailErrorVM> {
  try {
    const data = (await response.json()) as ApiErrorResponse;
    return {
      kind: "http",
      status: response.status,
      message: data.error.message,
      api: data,
    };
  } catch {
    return {
      kind: "http",
      status: response.status,
      message: `Request failed with status ${response.status}`,
    };
  }
}

/**
 * Map tutorial DTO to view model
 */
function mapDtoToVM(
  dto: GetTutorialDetailResponseDTO,
  isAuthenticated: boolean
): TutorialDetailVM {
  // Map header
  const header: TutorialHeaderVM = {
    title: dto.title,
    categoryLabel: formatCategory(dto.category),
    levelLabel: formatLevel(dto.level),
    difficultyLabel: formatDifficultyLabel(dto.difficulty_weight),
    createdAtLabel: formatCreatedAtLabel(dto.created_at),
  };

  // Sort steps by order ascending and map to VM
  const sortedSteps = [...dto.steps].sort((a, b) => a.order - b.order);
  const stepVMs: TutorialStepVM[] = sortedSteps.map((step: TutorialStep) => ({
    order: step.order,
    title: step.title,
    content: step.content,
  }));

  // Map sections
  const sections: TutorialSectionsVM = {
    summary: dto.summary,
    content: dto.content,
    steps: stepVMs,
    practiceRecommendations: dto.practice_recommendations,
    keyTakeaways: dto.key_takeaways,
  };

  // Map completion (only for authenticated users)
  let completion: TutorialCompletionVM | undefined = undefined;
  if (isAuthenticated) {
    completion = {
      isCompleted: dto.is_completed,
      completedAt: dto.completed_at,
    };
  }

  return {
    id: dto.id,
    header,
    sections,
    completion,
  };
}

/**
 * Custom hook for fetching tutorial detail
 */
export function useTutorialDetail(
  options: UseTutorialDetailOptions
): UseTutorialDetailReturn {
  const { tutorialId, isAuthenticated } = options;

  // Data state
  const [data, setData] = useState<TutorialDetailVM | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<TutorialDetailErrorVM | null>(null);
  const [isNotFound, setIsNotFound] = useState(false);

  // Abort controller for cleanup
  const abortControllerRef = useRef<AbortController | null>(null);

  /**
   * Fetch tutorial detail from API
   */
  const fetchDetail = useCallback(async () => {
    // Pre-validate UUID to avoid unnecessary API call
    if (!isUuid(tutorialId)) {
      setIsLoading(false);
      setIsNotFound(true);
      setError(null);
      setData(null);
      return;
    }

    // Cancel any in-flight request
    abortControllerRef.current?.abort();

    // Create new abort controller
    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setIsLoading(true);
    setError(null);
    setIsNotFound(false);

    try {
      const response = await fetch(`/api/tutorials/${tutorialId}`, {
        signal: abortController.signal,
      });

      if (!response.ok) {
        // Handle 404 or 400 (invalid UUID) as not found
        if (response.status === 404 || response.status === 400) {
          setIsNotFound(true);
          setData(null);
          setError(null);
        } else {
          // Handle other errors (500, network, etc.)
          const errorData = await parseApiError(response);
          setError(errorData);
          setData(null);
          setIsNotFound(false);
        }
        return;
      }

      // Success - parse and map to VM
      const dto = (await response.json()) as GetTutorialDetailResponseDTO;
      const vm = mapDtoToVM(dto, isAuthenticated);

      setData(vm);
      setError(null);
      setIsNotFound(false);
    } catch (err) {
      // Handle abort and network errors
      if (err instanceof Error && err.name === "AbortError") {
        // Request was cancelled, ignore
        return;
      }

      // Network error
      setError({
        kind: "network",
        message: "Couldn't load tutorial. Check your connection.",
      });
      setData(null);
      setIsNotFound(false);
    } finally {
      setIsLoading(false);
    }
  }, [tutorialId, isAuthenticated]);

  /**
   * Retry fetching data
   */
  const retry = useCallback(() => {
    fetchDetail();
  }, [fetchDetail]);

  /**
   * Fetch data on mount and when dependencies change
   */
  useEffect(() => {
    fetchDetail();

    // Cleanup on unmount
    return () => {
      abortControllerRef.current?.abort();
    };
  }, [fetchDetail]);

  return {
    data,
    isLoading,
    error,
    isNotFound,
    retry,
  };
}



================================================
FILE: src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
FILE: src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-all outline-none",
          "file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground",
          "placeholder:text-muted-foreground",
          "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
          "disabled:cursor-not-allowed disabled:opacity-50",
          "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



================================================
FILE: src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



================================================
FILE: src/components/ui/sonner.tsx
================================================
import { Toaster as Sonner } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster };



================================================
FILE: src/db/database.types.ts
================================================
[Binary file]


================================================
FILE: src/db/supabase.admin.ts
================================================
import { createClient } from '@supabase/supabase-js';
import type { Database } from './database.types.ts';

/**
 * Supabase Admin Client (Service Role)
 * 
 * WARNING: This client bypasses Row Level Security (RLS) policies.
 * Use ONLY for:
 * - Admin operations that require elevated privileges
 * - Server-side username lookup (auth.admin.getUserById)
 * - Cleanup operations (e.g., orphaned auth user removal)
 * 
 * NEVER use for regular user data operations - use the request-scoped
 * server client instead to ensure RLS policies are enforced.
 */
export const supabaseAdminClient = createClient<Database>(
  import.meta.env.SUPABASE_URL,
  import.meta.env.SUPABASE_SERVICE_ROLE_KEY,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  }
);



================================================
FILE: src/db/supabase.client.ts
================================================
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient as SupabaseClientBase } from '@supabase/supabase-js';
import { createServerClient, type CookieOptionsWithName } from '@supabase/ssr';
import type { AstroCookies } from 'astro';

import type { Database } from '../db/database.types.ts';

const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);

// Export typed SupabaseClient for use throughout the application
export type SupabaseClient = SupabaseClientBase<Database>;

/**
 * Cookie options for Supabase Auth session cookies
 * Configured for secure, HttpOnly, SameSite cookie handling
 */
export const cookieOptions: CookieOptionsWithName = {
  path: '/',
  secure: import.meta.env.PROD,
  httpOnly: true,
  sameSite: 'lax',
};

/**
 * Parses cookie header string into array of name-value pairs
 * Required for Supabase SSR cookie adapter
 */
function parseCookieHeader(cookieHeader: string): { name: string; value: string }[] {
  if (!cookieHeader) return [];
  
  return cookieHeader.split(';').map((cookie) => {
    const [name, ...rest] = cookie.trim().split('=');
    return { name, value: rest.join('=') };
  });
}

/**
 * Creates a request-scoped Supabase server client for SSR
 * Uses cookies for session management (HttpOnly, Secure)
 * 
 * CRITICAL: Use ONLY this client in API routes and middleware
 * to ensure proper cookie-backed authentication
 * 
 * @param context - Request context with headers and cookies
 * @returns Supabase client configured for SSR with cookie auth
 */
export const createSupabaseServerInstance = (context: {
  headers: Headers;
  cookies: AstroCookies;
}) => {
  const supabase = createServerClient<Database>(
    import.meta.env.SUPABASE_URL,
    import.meta.env.SUPABASE_KEY,
    {
      cookieOptions,
      cookies: {
        getAll() {
          return parseCookieHeader(context.headers.get('Cookie') ?? '');
        },
        setAll(cookiesToSet: { name: string; value: string; options: Record<string, unknown> }[]) {
          cookiesToSet.forEach(({ name, value, options }) =>
            context.cookies.set(name, value, options),
          );
        },
      },
    },
  );

  return supabase;
};



================================================
FILE: src/layouts/Layout.astro
================================================
---
import "../styles/global.css";
import Navbar from "../components/nav/Navbar.astro";
import { ToastHost } from "../components/shared/ToastHost";

interface Props {
  title?: string;
}

const { title = "Cook Mastery" } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <ToastHost client:load />
    <div class="flex min-h-screen flex-col">
      <header>
        <Navbar />
      </header>
      <main class="flex-1">
        <slot />
      </main>
    </div>
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>



================================================
FILE: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: src/lib/services/article.service.ts
================================================
/**
 * Article Service
 *
 * Handles business logic for article-related operations including
 * listing articles with filters, sorting, pagination, and completion status.
 */

import type { SupabaseClient } from "../../db/supabase.client";
import type {
  ListArticlesParams,
  ListArticlesResponseDTO,
  ArticleListItemDTO,
  PaginationMeta,
  GetArticleDetailResponseDTO,
  CompleteArticleResponseDTO,
} from "../../types";

/**
 * Lists articles with optional filtering, sorting, and pagination
 *
 * @param supabase - Supabase client instance
 * @param params - Query parameters for filtering and pagination
 * @param userId - Optional authenticated user ID for completion status
 * @returns Promise resolving to articles list with pagination metadata
 * @throws Error if database query fails
 */
export async function listArticles(
  supabase: SupabaseClient,
  params: ListArticlesParams,
  userId?: string
): Promise<ListArticlesResponseDTO> {
  const { level, sort = "difficulty_asc", page = 1, limit = 20, include_completed = true } = params;

  // Build base query for articles
  let query = supabase
    .from("articles")
    .select("id, title, level, difficulty_weight, summary, created_at", { count: "exact" });

  // Apply level filter if provided
  if (level) {
    query = query.eq("level", level);
  }

  // Apply sorting
  if (sort === "difficulty_asc") {
    // Sort by difficulty weight ascending, then by creation date descending
    query = query.order("difficulty_weight", { ascending: true }).order("created_at", { ascending: false });
  } else if (sort === "newest") {
    // Sort by creation date descending
    query = query.order("created_at", { ascending: false });
  }

  // Apply pagination
  const from = (page - 1) * limit;
  const to = from + limit - 1;
  query = query.range(from, to);

  // Execute main query
  const { data: articles, error, count } = await query;

  if (error) {
    console.error("Error fetching articles:", error);
    throw new Error("Failed to fetch articles from database");
  }

  if (!articles) {
    throw new Error("No data returned from articles query");
  }

  // Fetch completion status if user is authenticated and requested
  const completionMap = new Map<string, string>();

  if (userId && include_completed && articles.length > 0) {
    // Query completions only for the current page's article IDs
    const articleIds = articles.map((article) => article.id);

    const { data: completions, error: completionError } = await supabase
      .from("user_articles")
      .select("article_id, completed_at")
      .eq("user_id", userId)
      .in("article_id", articleIds);

    if (completionError) {
      // Log error but don't fail the request - graceful degradation
      console.error("Error fetching completion status:", completionError);
    } else if (completions) {
      // Build lookup map: articleId -> completed_at
      completions.forEach((completion) => {
        completionMap.set(completion.article_id, completion.completed_at);
      });
    }
  }

  // Map articles to DTOs with completion status
  const articleDTOs: ArticleListItemDTO[] = articles.map((article) => ({
    id: article.id,
    title: article.title,
    level: article.level,
    difficulty_weight: article.difficulty_weight,
    summary: article.summary,
    created_at: article.created_at,
    is_completed: completionMap.has(article.id),
    completed_at: completionMap.get(article.id) ?? null,
  }));

  // Calculate pagination metadata
  const totalItems = count ?? 0;
  const totalPages = Math.ceil(totalItems / limit);

  const paginationMeta: PaginationMeta = {
    page,
    limit,
    total_items: totalItems,
    total_pages: totalPages,
  };

  return {
    articles: articleDTOs,
    pagination: paginationMeta,
  };
}

/**
 * Retrieves detailed information for a single article by ID
 *
 * @param supabase - Supabase client instance
 * @param articleId - UUID of the article to retrieve
 * @param userId - Optional authenticated user ID for completion status
 * @returns Promise resolving to article detail or null if not found
 * @throws Error if database query fails
 */
export async function getArticleDetail(
  supabase: SupabaseClient,
  articleId: string,
  userId?: string
): Promise<GetArticleDetailResponseDTO | null> {
  // Fetch article data
  const { data: article, error } = await supabase
    .from("articles")
    .select(
      `
      id,
      title,
      level,
      difficulty_weight,
      summary,
      content,
      key_takeaways,
      created_at,
      updated_at
    `
    )
    .eq("id", articleId)
    .single();

  if (error || !article) {
    return null;
  }

  // Fetch completion status if user is authenticated
  let completionData = null;
  if (userId) {
    const { data: completion } = await supabase
      .from("user_articles")
      .select("completed_at")
      .eq("user_id", userId)
      .eq("article_id", articleId)
      .maybeSingle();

    completionData = completion;
  }

  // Construct and return response DTO
  return {
    id: article.id,
    title: article.title,
    level: article.level,
    difficulty_weight: article.difficulty_weight,
    summary: article.summary,
    content: article.content,
    key_takeaways: article.key_takeaways,
    created_at: article.created_at,
    updated_at: article.updated_at,
    is_completed: !!completionData,
    completed_at: completionData?.completed_at || null,
  };
}

/**
 * Records article completion for a user (idempotent)
 *
 * @param supabase - Supabase client instance
 * @param articleId - UUID of the article to mark as completed
 * @param userId - UUID of the authenticated user
 * @returns Promise resolving to completion response DTO
 * @throws Error if article doesn't exist or database operation fails
 */
export async function completeArticle(
  supabase: SupabaseClient,
  articleId: string,
  userId: string
): Promise<CompleteArticleResponseDTO> {
  // First, verify that the article exists
  const { data: article, error: articleError } = await supabase
    .from("articles")
    .select("id")
    .eq("id", articleId)
    .maybeSingle();

  if (articleError) {
    throw new Error("Failed to verify article existence");
  }

  if (!article) {
    throw new Error("Article not found");
  }

  // Check if completion record already exists
  const { data: existingCompletion, error: checkError } = await supabase
    .from("user_articles")
    .select("article_id, user_id, completed_at")
    .eq("user_id", userId)
    .eq("article_id", articleId)
    .maybeSingle();

  if (checkError) {
    throw new Error("Failed to check existing completion status");
  }

  // If already completed, return existing record with status
  if (existingCompletion) {
    return {
      article_id: existingCompletion.article_id,
      user_id: existingCompletion.user_id,
      completed_at: existingCompletion.completed_at,
      status: "already_completed",
    };
  }

  // Insert new completion record
  const { data: newCompletion, error: insertError } = await supabase
    .from("user_articles")
    .insert({
      user_id: userId,
      article_id: articleId,
    })
    .select("article_id, user_id, completed_at")
    .single();

  if (insertError || !newCompletion) {
    throw new Error("Failed to record article completion");
  }

  return {
    article_id: newCompletion.article_id,
    user_id: newCompletion.user_id,
    completed_at: newCompletion.completed_at,
    status: "created",
  };
}



================================================
FILE: src/lib/services/cookbook.service.ts
================================================
/**
 * Cookbook Service
 *
 * Handles business logic for cookbook-related operations including
 * listing saved entries, CRUD operations with sorting and pagination for authenticated users.
 */

import type { SupabaseClient } from "../../db/supabase.client";
import type {
  ListCookbookEntriesParams,
  ListCookbookEntriesResponseDTO,
  CookbookEntryDTO,
  PaginationMeta,
  CreateCookbookEntryCommand,
  UpdateCookbookEntryCommand,
} from "../../types";

/**
 * Lists cookbook entries for a specific user with sorting and pagination
 *
 * @param supabase - Supabase client instance
 * @param params - Query parameters for sorting and pagination
 * @param userId - Authenticated user ID (required for data isolation)
 * @returns Promise resolving to cookbook entries list with pagination metadata
 * @throws Error if database query fails
 */
export async function listCookbookEntries(
  supabase: SupabaseClient,
  params: ListCookbookEntriesParams,
  userId: string
): Promise<ListCookbookEntriesResponseDTO> {
  const { sort = "newest", page = 1, limit = 20 } = params;

  // Build base query for cookbook entries
  let query = supabase
    .from("cookbook_entries")
    .select("id, user_id, url, title, notes, created_at, updated_at", { count: "exact" })
    .eq("user_id", userId); // Defense-in-depth: explicit user_id filter even with RLS

  // Apply sorting with stable tie-breakers for consistent pagination
  if (sort === "newest") {
    // Newest first: sort by created_at descending, then by id descending
    query = query
      .order("created_at", { ascending: false })
      .order("id", { ascending: false });
  } else if (sort === "oldest") {
    // Oldest first: sort by created_at ascending, then by id ascending
    query = query
      .order("created_at", { ascending: true })
      .order("id", { ascending: true });
  } else if (sort === "title_asc") {
    // Alphabetical by title: sort by title ascending, then created_at descending, then id descending
    query = query
      .order("title", { ascending: true })
      .order("created_at", { ascending: false })
      .order("id", { ascending: false });
  }

  // Apply pagination using range
  const from = (page - 1) * limit;
  const to = from + limit - 1;
  query = query.range(from, to);

  // Execute query
  const { data, error, count } = await query;

  // Handle database errors
  if (error) {
    throw new Error(`Failed to fetch cookbook entries: ${error.message}`);
  }

  // Map results to DTOs (should already match the selected columns)
  const entries: CookbookEntryDTO[] = data || [];

  // Compute pagination metadata
  const total_items = count ?? 0;
  const total_pages = Math.ceil(total_items / limit);

  const pagination: PaginationMeta = {
    page,
    limit,
    total_items,
    total_pages,
  };

  return {
    entries,
    pagination,
  };
}

/**
 * Gets a single cookbook entry by ID for a specific user
 *
 * @param supabase - Supabase client instance
 * @param userId - Authenticated user ID (required for authorization)
 * @param entryId - Cookbook entry UUID
 * @returns Promise resolving to cookbook entry DTO or null if not found
 * @throws Error if database query fails
 */
export async function getCookbookEntry(
  supabase: SupabaseClient,
  userId: string,
  entryId: string
): Promise<CookbookEntryDTO | null> {
  const { data, error } = await supabase
    .from("cookbook_entries")
    .select("id, user_id, url, title, notes, created_at, updated_at")
    .eq("id", entryId)
    .eq("user_id", userId) // Defense-in-depth: explicit user_id filter even with RLS
    .single();

  if (error) {
    // If error code is PGRST116, it means no rows returned (not found)
    if (error.code === "PGRST116") {
      return null;
    }
    throw new Error(`Failed to fetch cookbook entry: ${error.message}`);
  }

  return data as CookbookEntryDTO;
}

/**
 * Creates a new cookbook entry for a specific user
 *
 * @param supabase - Supabase client instance
 * @param userId - Authenticated user ID (required for ownership)
 * @param command - Command object containing url, title, and optional notes
 * @returns Promise resolving to created cookbook entry DTO
 * @throws Error if database insert fails
 */
export async function createCookbookEntry(
  supabase: SupabaseClient,
  userId: string,
  command: CreateCookbookEntryCommand
): Promise<CookbookEntryDTO> {
  const { data, error } = await supabase
    .from("cookbook_entries")
    .insert({
      user_id: userId,
      url: command.url,
      title: command.title,
      notes: command.notes ?? null,
    })
    .select("id, user_id, url, title, notes, created_at, updated_at")
    .single();

  if (error) {
    throw new Error(`Failed to create cookbook entry: ${error.message}`);
  }

  return data as CookbookEntryDTO;
}

/**
 * Updates an existing cookbook entry for a specific user
 *
 * @param supabase - Supabase client instance
 * @param userId - Authenticated user ID (required for authorization)
 * @param entryId - Cookbook entry UUID to update
 * @param command - Command object containing optional url, title, and/or notes
 * @returns Promise resolving to updated cookbook entry DTO or null if not found
 * @throws Error if database update fails
 */
export async function updateCookbookEntry(
  supabase: SupabaseClient,
  userId: string,
  entryId: string,
  command: UpdateCookbookEntryCommand
): Promise<CookbookEntryDTO | null> {
  // Build update object only with provided fields
  const updateData: Record<string, unknown> = {};
  if (command.url !== undefined) updateData.url = command.url;
  if (command.title !== undefined) updateData.title = command.title;
  if (command.notes !== undefined) updateData.notes = command.notes;

  const { data, error } = await supabase
    .from("cookbook_entries")
    .update(updateData)
    .eq("id", entryId)
    .eq("user_id", userId) // Defense-in-depth: explicit user_id filter even with RLS
    .select("id, user_id, url, title, notes, created_at, updated_at")
    .single();

  if (error) {
    // If error code is PGRST116, it means no rows returned (not found)
    if (error.code === "PGRST116") {
      return null;
    }
    throw new Error(`Failed to update cookbook entry: ${error.message}`);
  }

  return data as CookbookEntryDTO;
}

/**
 * Deletes a cookbook entry for a specific user
 *
 * @param supabase - Supabase client instance
 * @param userId - Authenticated user ID (required for authorization)
 * @param entryId - Cookbook entry UUID to delete
 * @returns Promise resolving to true if deleted, false if not found
 * @throws Error if database delete fails
 */
export async function deleteCookbookEntry(
  supabase: SupabaseClient,
  userId: string,
  entryId: string
): Promise<boolean> {
  const { error, count } = await supabase
    .from("cookbook_entries")
    .delete({ count: "exact" })
    .eq("id", entryId)
    .eq("user_id", userId); // Defense-in-depth: explicit user_id filter even with RLS

  if (error) {
    throw new Error(`Failed to delete cookbook entry: ${error.message}`);
  }

  // Return true if at least one row was deleted
  return (count ?? 0) > 0;
}



================================================
FILE: src/lib/services/profile.service.ts
================================================
/**
 * Profile Service
 * 
 * Handles user profile operations including fetching and updating profile information.
 */

import type { SupabaseClient } from '../../db/supabase.client';
import type { ProfileDTO, UpdateProfileCommand } from '../../types';
import { createErrorResponse } from '../utils/error-handler';

/**
 * Updates user profile information
 * 
 * @param supabase - Authenticated Supabase client
 * @param userId - ID of the user to update
 * @param command - Update command with fields to change
 * @returns Updated profile DTO
 * @throws ApiErrorResponse if update fails
 */
export async function updateProfile(
  supabase: SupabaseClient,
  userId: string,
  command: UpdateProfileCommand
): Promise<ProfileDTO> {
  // Handle edge case: reject empty update command
  if (!command.username && !command.selected_level) {
    throw createErrorResponse(
      'VALIDATION_ERROR',
      'At least one field must be provided for update',
      { general: 'No fields to update' }
    );
  }

  // Build update object
  const updateData: Record<string, unknown> = {
    updated_at: new Date().toISOString(),
  };

  if (command.username !== undefined) {
    updateData.username = command.username;
  }

  if (command.selected_level !== undefined) {
    updateData.selected_level = command.selected_level;
  }

  // Perform update
  const { data, error } = await supabase
    .from('profiles')
    .update(updateData)
    .eq('id', userId)
    .select('id, username, selected_level, created_at, updated_at')
    .single();

  // Handle database errors
  if (error) {
    // Check for unique constraint violation on username
    if (error.code === '23505') {
      throw createErrorResponse(
        'CONFLICT',
        'Username already taken',
        { username: 'This username is already in use' }
      );
    }

    console.error('[profile.service] Update failed:', error);
    throw createErrorResponse(
      'INTERNAL_SERVER_ERROR',
      'Failed to update profile'
    );
  }

  // Validate that record was updated
  if (!data) {
    throw createErrorResponse(
      'NOT_FOUND',
      'Profile not found'
    );
  }

  return data;
}



================================================
FILE: src/lib/services/progress.service.ts
================================================
/**
 * Progress Service
 * 
 * Handles user progress tracking and aggregation across difficulty levels.
 */

import type { SupabaseClient } from '../../db/supabase.client';
import type { UserProgressSummaryDTO, LevelProgressDTO, DifficultyLevel } from '../../types';
import { createErrorResponse } from '../utils/error-handler';

/**
 * Fetches user progress summary across all difficulty levels
 * 
 * @param supabase - Authenticated Supabase client
 * @param userId - ID of the user
 * @param selectedLevel - User's currently selected difficulty level
 * @returns Progress summary with level-specific progress data
 * @throws ApiErrorResponse if fetch fails
 */
export async function getUserProgressSummary(
  supabase: SupabaseClient,
  userId: string,
  selectedLevel: DifficultyLevel
): Promise<UserProgressSummaryDTO> {
  // Query the user_level_progress view for all levels
  const { data, error } = await supabase
    .from('user_level_progress')
    .select('*')
    .eq('user_id', userId);

  // Handle database errors
  if (error) {
    console.error('[progress.service] Failed to fetch progress:', error);
    throw createErrorResponse(
      'INTERNAL_SERVER_ERROR',
      'Failed to fetch progress data'
    );
  }

  // Transform raw data into LevelProgressDTO array
  const levelProgress: LevelProgressDTO[] = (data || []).map((row) => ({
    level: row.level as DifficultyLevel,
    total_count: row.total_count || 0,
    completed_count: row.completed_count || 0,
    completion_percent: row.completion_percent || 0,
    is_up_to_date: row.is_up_to_date || false,
  }));

  // Ensure all three levels are represented (fill in missing levels with zero progress)
  const allLevels: DifficultyLevel[] = ['BEGINNER', 'INTERMEDIATE', 'EXPERIENCED'];
  const completeLevelProgress: LevelProgressDTO[] = allLevels.map((level) => {
    const existing = levelProgress.find((lp) => lp.level === level);
    return existing || {
      level,
      total_count: 0,
      completed_count: 0,
      completion_percent: 0,
      is_up_to_date: false,
    };
  });

  // Find selected level's progress to determine advancement eligibility
  const selectedLevelProgress = completeLevelProgress.find((lp) => lp.level === selectedLevel);
  const completionPercent = selectedLevelProgress?.completion_percent || 0;
  
  // User can advance if:
  // 1. Completion >= 85% for selected level
  // 2. Selected level is not already EXPERIENCED
  const canAdvance = completionPercent >= 85 && selectedLevel !== 'EXPERIENCED';

  return {
    user_id: userId,
    selected_level: selectedLevel,
    level_progress: completeLevelProgress,
    can_advance: canAdvance,
  };
}



================================================
FILE: src/lib/services/tutorial.service.ts
================================================
/**
 * Tutorial Service
 *
 * Handles business logic for tutorial-related operations including
 * listing tutorials with filters, sorting, pagination, and completion status.
 */

import type { SupabaseClient } from "../../db/supabase.client";
import type {
  ListTutorialsParams,
  ListTutorialsResponseDTO,
  TutorialListItemDTO,
  PaginationMeta,
  GetTutorialDetailResponseDTO,
  TutorialStep,
  CompleteTutorialResponseDTO,
} from "../../types";

/**
 * Lists tutorials with optional filtering, sorting, and pagination
 *
 * @param supabase - Supabase client instance
 * @param params - Query parameters for filtering and pagination
 * @param userId - Optional authenticated user ID for completion status
 * @returns Promise resolving to tutorials list with pagination metadata
 * @throws Error if database query fails
 */
export async function listTutorials(
  supabase: SupabaseClient,
  params: ListTutorialsParams,
  userId?: string
): Promise<ListTutorialsResponseDTO> {
  const { level, category, sort = "difficulty_asc", page = 1, limit = 20, include_completed = true } = params;

  // Build base query for tutorials
  let query = supabase
    .from("tutorials")
    .select("id, title, category, level, difficulty_weight, summary, created_at", { count: "exact" });

  // Apply level filter if provided
  if (level) {
    query = query.eq("level", level);
  }

  // Apply category filter if provided
  if (category) {
    query = query.eq("category", category);
  }

  // Apply sorting
  if (sort === "difficulty_asc") {
    // Sort by difficulty weight ascending, then by creation date descending
    query = query.order("difficulty_weight", { ascending: true }).order("created_at", { ascending: false });
  } else if (sort === "newest") {
    // Sort by creation date descending
    query = query.order("created_at", { ascending: false });
  }

  // Apply pagination
  const from = (page - 1) * limit;
  const to = from + limit - 1;
  query = query.range(from, to);

  // Execute main query
  const { data: tutorials, error, count } = await query;

  if (error) {
    console.error("Error fetching tutorials:", error);
    throw new Error("Failed to fetch tutorials from database");
  }

  if (!tutorials) {
    throw new Error("No data returned from tutorials query");
  }

  // Fetch completion status if user is authenticated and requested
  let completedTutorialIds = new Set<string>();

  if (userId && include_completed) {
    const { data: completedTutorials, error: completionError } = await supabase
      .from("user_tutorials")
      .select("tutorial_id")
      .eq("user_id", userId);

    if (completionError) {
      // Log error but don't fail the request - graceful degradation
      console.error("Error fetching completion status:", completionError);
    } else if (completedTutorials) {
      completedTutorialIds = new Set(completedTutorials.map((t) => t.tutorial_id));
    }
  }

  // Map tutorials to DTOs with completion status
  const tutorialDTOs: TutorialListItemDTO[] = tutorials.map((tutorial) => ({
    id: tutorial.id,
    title: tutorial.title,
    category: tutorial.category,
    level: tutorial.level,
    difficulty_weight: tutorial.difficulty_weight,
    summary: tutorial.summary,
    created_at: tutorial.created_at,
    is_completed: completedTutorialIds.has(tutorial.id),
  }));

  // Calculate pagination metadata
  const totalItems = count ?? 0;
  const totalPages = Math.ceil(totalItems / limit);

  const paginationMeta: PaginationMeta = {
    page,
    limit,
    total_items: totalItems,
    total_pages: totalPages,
  };

  return {
    tutorials: tutorialDTOs,
    pagination: paginationMeta,
  };
}

/**
 * Retrieves detailed information for a specific tutorial
 *
 * @param supabase - Supabase client instance
 * @param tutorialId - UUID of the tutorial to retrieve
 * @param userId - Optional authenticated user ID for completion status
 * @returns Promise resolving to tutorial detail DTO or null if not found
 * @throws Error if database query fails
 */
export async function getTutorialDetail(
  supabase: SupabaseClient,
  tutorialId: string,
  userId?: string
): Promise<GetTutorialDetailResponseDTO | null> {
  // Fetch tutorial data
  const { data: tutorial, error } = await supabase
    .from("tutorials")
    .select(
      `
      id,
      title,
      category,
      level,
      difficulty_weight,
      summary,
      content,
      steps,
      practice_recommendations,
      key_takeaways,
      created_at,
      updated_at
    `
    )
    .eq("id", tutorialId)
    .single();

  if (error || !tutorial) {
    return null;
  }

  // Fetch completion status if user is authenticated
  let completionData = null;
  if (userId) {
    const { data: completion } = await supabase
      .from("user_tutorials")
      .select("completed_at")
      .eq("user_id", userId)
      .eq("tutorial_id", tutorialId)
      .maybeSingle();

    completionData = completion;
  }

  // Parse JSONB steps field with type safety
  const steps: TutorialStep[] = Array.isArray(tutorial.steps) ? (tutorial.steps as unknown as TutorialStep[]) : [];

  // Construct and return response DTO
  return {
    id: tutorial.id,
    title: tutorial.title,
    category: tutorial.category,
    level: tutorial.level,
    difficulty_weight: tutorial.difficulty_weight,
    summary: tutorial.summary,
    content: tutorial.content,
    steps,
    practice_recommendations: tutorial.practice_recommendations,
    key_takeaways: tutorial.key_takeaways,
    created_at: tutorial.created_at,
    updated_at: tutorial.updated_at,
    is_completed: !!completionData,
    completed_at: completionData?.completed_at || null,
  };
}

/**
 * Records tutorial completion for a user (idempotent)
 *
 * @param supabase - Supabase client instance
 * @param tutorialId - UUID of the tutorial to mark as completed
 * @param userId - UUID of the authenticated user
 * @returns Promise resolving to completion response DTO
 * @throws Error if tutorial doesn't exist or database operation fails
 */
export async function completeTutorial(
  supabase: SupabaseClient,
  tutorialId: string,
  userId: string
): Promise<CompleteTutorialResponseDTO> {
  // First, verify that the tutorial exists
  const { data: tutorial, error: tutorialError } = await supabase
    .from("tutorials")
    .select("id")
    .eq("id", tutorialId)
    .maybeSingle();

  if (tutorialError) {
    throw new Error("Failed to verify tutorial existence");
  }

  if (!tutorial) {
    throw new Error("Tutorial not found");
  }

  // Check if completion record already exists
  const { data: existingCompletion, error: checkError } = await supabase
    .from("user_tutorials")
    .select("tutorial_id, user_id, completed_at")
    .eq("user_id", userId)
    .eq("tutorial_id", tutorialId)
    .maybeSingle();

  if (checkError) {
    throw new Error("Failed to check existing completion status");
  }

  // If already completed, return existing record with status
  if (existingCompletion) {
    return {
      tutorial_id: existingCompletion.tutorial_id,
      user_id: existingCompletion.user_id,
      completed_at: existingCompletion.completed_at,
      status: "already_completed",
    };
  }

  // Insert new completion record
  const { data: newCompletion, error: insertError } = await supabase
    .from("user_tutorials")
    .insert({
      user_id: userId,
      tutorial_id: tutorialId,
    })
    .select("tutorial_id, user_id, completed_at")
    .single();

  if (insertError || !newCompletion) {
    throw new Error("Failed to record tutorial completion");
  }

  return {
    tutorial_id: newCompletion.tutorial_id,
    user_id: newCompletion.user_id,
    completed_at: newCompletion.completed_at,
    status: "created",
  };
}



================================================
FILE: src/lib/utils/error-handler.ts
================================================
/**
 * Error Handling Utilities
 * 
 * Provides standardized error response formatting and HTTP status code handling
 * for API endpoints across the application.
 */

import type { ApiErrorResponse } from '../../types';
import { ZodError } from 'zod';

/**
 * Creates a standardized API error response
 * 
 * @param code - Error code identifier
 * @param message - Human-readable error message
 * @param details - Optional additional error details
 * @returns ApiErrorResponse object
 */
export function createErrorResponse(
  code: string,
  message: string,
  details?: Record<string, string>
): ApiErrorResponse {
  return {
    error: {
      code,
      message,
      details,
    },
  };
}

/**
 * Formats Zod validation errors into API error response format
 * 
 * @param error - ZodError from validation failure
 * @returns ApiErrorResponse with validation error details
 */
export function formatZodError(error: ZodError): ApiErrorResponse {
  const details: Record<string, string> = {};

  error.errors.forEach((err) => {
    // Use 'general' as key if path is empty (for refine/superRefine errors)
    const path = err.path.length > 0 ? err.path.join('.') : 'general';
    details[path] = err.message;
  });

  return createErrorResponse(
    'VALIDATION_ERROR',
    'Validation failed',
    details
  );
}

/**
 * Creates a JSON response with appropriate status code
 * 
 * @param data - Response data to serialize
 * @param status - HTTP status code
 * @returns Response object
 */
export function createJsonResponse(data: unknown, status: number = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
    },
  });
}

/**
 * Logs error with context information
 * 
 * @param context - Context string (e.g., 'GET /api/tutorials')
 * @param error - Error object
 * @param additionalInfo - Optional additional context
 */
export function logError(
  context: string,
  error: unknown,
  additionalInfo?: Record<string, unknown>
): void {
  console.error(`[${context}]`, {
    error: error instanceof Error ? error.message : String(error),
    stack: error instanceof Error ? error.stack : undefined,
    ...additionalInfo,
  });
}



================================================
FILE: src/middleware/index.ts
================================================
import { defineMiddleware } from 'astro:middleware';
import { createSupabaseServerInstance } from '../db/supabase.client.ts';
import type { ProfileDTO } from '../types.ts';

/**
 * Public paths that don't require authentication
 * Note: Home (/) is public but shows personalized content when authenticated
 */
const PUBLIC_PATHS = [
  '/',
  '/login',
  '/signup',
  // API auth endpoints
  '/api/auth/login',
  '/api/auth/signup',
  '/api/auth/logout',
];

/**
 * Auth page paths that should redirect authenticated users away
 */
const AUTH_PAGE_PATHS = ['/login', '/signup'];

/**
 * Protected paths that require authentication
 */
const PROTECTED_PATHS = ['/profile', '/cookbook'];

/**
 * Check if path is protected
 */
function isProtectedPath(pathname: string): boolean {
  return PROTECTED_PATHS.some(
    (path) => pathname === path || pathname.startsWith(`${path}/`)
  );
}

/**
 * Middleware: Authentication and session management
 * 
 * Responsibilities:
 * - Create request-scoped Supabase client with cookie-backed auth
 * - Populate locals.user and locals.profile for all authenticated requests
 * - Redirect authenticated users away from auth pages (/login, /signup)
 * - Redirect unauthenticated users away from protected pages
 */
export const onRequest = defineMiddleware(async ({ locals, cookies, url, request, redirect }, next) => {
  // Create request-scoped Supabase server client
  const supabase = createSupabaseServerInstance({
    cookies,
    headers: request.headers,
  });

  // Store supabase client in locals for use in API routes
  locals.supabase = supabase;

  // Get authenticated user from session
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // If user is authenticated, fetch profile and populate locals
  if (user) {
    locals.user = {
      id: user.id,
      email: user.email ?? '',
    };

    // Fetch profile from database
    const { data: profile } = await supabase
      .from('profiles')
      .select('id, username, selected_level, created_at, updated_at')
      .eq('id', user.id)
      .single();

    if (profile) {
      locals.profile = profile as ProfileDTO;
    }

    // Redirect authenticated users away from auth pages
    if (AUTH_PAGE_PATHS.includes(url.pathname)) {
      return redirect('/');
    }
  } else {
    // User is not authenticated
    // Redirect to login if trying to access protected path
    if (isProtectedPath(url.pathname) && !PUBLIC_PATHS.includes(url.pathname)) {
      return redirect('/login');
    }
  }

  return next();
});



================================================
FILE: src/pages/index.astro
================================================
---
import Layout from "../layouts/Layout.astro";
import HomeView from "../components/home/HomeView";
---

<Layout title="Cook Mastery — Home">
  <HomeView client:load />
</Layout>



================================================
FILE: src/pages/learning.astro
================================================
---
/**
 * Learning Page - Public browsable view for all content
 * Allows users to browse tutorials and articles with filtering and pagination
 * Works for both anonymous and authenticated users
 */

import Layout from "../layouts/Layout.astro";
import LearningView from "../components/learning/LearningView";

// Read authenticated context from middleware-populated locals
const user = Astro.locals.user;
const profile = Astro.locals.profile;

// Derive props for LearningView
const isAuthenticated = !!user && !!profile;
const userSelectedLevel = profile?.selected_level;

// Initialize level filter based on authentication status
// Authenticated: use user's selected_level
// Anonymous: use "ALL"
const initialLevelFilter = isAuthenticated && userSelectedLevel ? userSelectedLevel : "ALL";
const initialTypeFilter = "all"; // Always default to "all"
---

<Layout title="Learning — Cook Mastery">
  <main class="container mx-auto w-full max-w-6xl px-4 py-6">
    <LearningView
      client:load
      isAuthenticated={isAuthenticated}
      userSelectedLevel={userSelectedLevel}
      initialLevelFilter={initialLevelFilter}
      initialTypeFilter={initialTypeFilter}
    />
  </main>
</Layout>



================================================
FILE: src/pages/login.astro
================================================
---
import Layout from "../layouts/Layout.astro";
import { AuthFormLogin } from "../components/auth/AuthFormLogin";

// Redirect authenticated users to home page
// This is a backup to middleware protection
if (Astro.locals.user) {
  return Astro.redirect('/');
}
---

<Layout title="Log in — Cook Mastery">
  <div class="container mx-auto px-4 py-8 md:py-16">
    <AuthFormLogin client:load />
  </div>
</Layout>



================================================
FILE: src/pages/profile.astro
================================================
---
/**
 * Profile page
 * Displays user profile information and settings
 * Allows authenticated users to view their information and log out
 */
import Layout from '../layouts/Layout.astro';
import ProfileView from '../components/profile/ProfileView.tsx';

// Get user and profile from middleware (guaranteed to exist due to auth protection)
const { user, profile } = Astro.locals;

// If no user or profile, this shouldn't happen due to middleware redirect
if (!user || !profile) {
  return Astro.redirect('/login');
}
---

<Layout title="Profile — Cook Mastery">
  <div class="container mx-auto px-4 py-8 md:py-16">
    <ProfileView user={user} profile={profile} client:load />
  </div>
</Layout>



================================================
FILE: src/pages/signup.astro
================================================
---
import Layout from "../layouts/Layout.astro";
import { AuthFormSignup } from "../components/auth/AuthFormSignup";

// Redirect authenticated users to home page
// This is a backup to middleware protection
if (Astro.locals.user) {
  return Astro.redirect('/');
}
---

<Layout title="Sign up — Cook Mastery">
  <div class="container mx-auto px-4 py-8 md:py-16">
    <AuthFormSignup client:load />
  </div>
</Layout>



================================================
FILE: src/pages/api/profile.ts
================================================
/**
 * /api/profile
 *
 * Handles user profile operations:
 * - PATCH: Updates profile information (username or selected_level)
 *
 * Requires authentication - returns 401 if user is not logged in.
 */

import type { APIContext } from 'astro';
import { z } from 'zod';
import { updateProfile } from '../../lib/services/profile.service';
import {
  createErrorResponse,
  createJsonResponse,
  formatZodError,
  logError,
} from '../../lib/utils/error-handler';
import type { UpdateProfileCommand, ProfileDTO } from '../../types';

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating PATCH /api/profile request body
 * At least one field must be present
 */
const UpdateProfileBodySchema = z
  .object({
    username: z.string().min(1, 'Username cannot be empty').optional(),
    selected_level: z.enum(['BEGINNER', 'INTERMEDIATE', 'EXPERIENCED']).optional(),
  })
  .refine(
    (data) => data.username !== undefined || data.selected_level !== undefined,
    {
      message: 'At least one field must be provided for update',
      path: ['general'],
    }
  );

/**
 * PATCH handler for updating user profile
 *
 * Request Body:
 * - username: New username (optional)
 * - selected_level: New difficulty level (optional)
 *
 * Returns:
 * - 200: Success with updated profile DTO
 * - 400: Invalid request body
 * - 401: User not authenticated
 * - 409: Conflict (e.g., username already taken)
 * - 500: Internal server error
 */
export async function PATCH(context: APIContext): Promise<Response> {
  try {
    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse('UNAUTHORIZED', 'Authentication required to update profile'),
        401
      );
    }

    // Parse and validate request body
    let requestBody: unknown;
    try {
      requestBody = await context.request.json();
    } catch {
      return createJsonResponse(
        createErrorResponse('VALIDATION_ERROR', 'Invalid JSON in request body'),
        400
      );
    }

    const validationResult = UpdateProfileBodySchema.safeParse(requestBody);

    if (!validationResult.success) {
      return createJsonResponse(formatZodError(validationResult.error), 400);
    }

    const command: UpdateProfileCommand = validationResult.data;

    // Call service to update profile
    const updatedProfile: ProfileDTO = await updateProfile(supabase, user.id, command);

    // Return successful response
    return new Response(JSON.stringify(updatedProfile), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'private, no-cache',
      },
    });
  } catch (error: unknown) {
    // Handle service-level errors (thrown as ApiErrorResponse)
    if (
      error &&
      typeof error === 'object' &&
      'error' in error &&
      typeof error.error === 'object' &&
      error.error !== null &&
      'code' in error.error
    ) {
      const apiError = error as { error: { code: string; message: string } };
      const statusMap: Record<string, number> = {
        VALIDATION_ERROR: 400,
        UNAUTHORIZED: 401,
        FORBIDDEN: 403,
        NOT_FOUND: 404,
        CONFLICT: 409,
        INTERNAL_SERVER_ERROR: 500,
      };
      const status = statusMap[apiError.error.code] || 500;
      return createJsonResponse(error, status);
    }

    // Log unexpected errors
    logError('PATCH /api/profile', error, { userId: context.locals.user?.id });

    // Return generic 500 error
    return createJsonResponse(
      createErrorResponse('INTERNAL_SERVER_ERROR', 'An unexpected error occurred'),
      500
    );
  }
}



================================================
FILE: src/pages/api/articles/[id].ts
================================================
/**
 * GET /api/articles/:id
 *
 * Retrieves comprehensive information about a specific article.
 * Public endpoint accessible to both authenticated and anonymous users.
 * Authenticated users receive their completion status and completion timestamp.
 */

import type { APIContext } from "astro";
import { z } from "zod";
import { getArticleDetail } from "../../../lib/services/article.service";
import { createErrorResponse, createJsonResponse, formatZodError, logError } from "../../../lib/utils/error-handler";

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating path parameters
 * Ensures the article ID is a valid UUID format
 */
const ArticleIdParamSchema = z.object({
  id: z.string().uuid({ message: "Invalid article ID format" }),
});

/**
 * GET handler for retrieving a specific article
 *
 * Path Parameters:
 * - id: UUID of the article to retrieve
 *
 * Returns:
 * - 200: Success with full article details
 * - 400: Invalid UUID format
 * - 404: Article not found
 * - 500: Internal server error
 */
export async function GET(context: APIContext): Promise<Response> {
  try {
    // Step 1: Extract and validate path parameter
    const validationResult = ArticleIdParamSchema.safeParse(context.params);

    if (!validationResult.success) {
      return createJsonResponse(formatZodError(validationResult.error), 400);
    }

    const { id: articleId } = validationResult.data;

    // Step 2: Check if user is authenticated (optional for this endpoint)
    const supabase = context.locals.supabase;
    let userId: string | undefined;

    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      userId = user?.id;
    } catch (authError) {
      // Authentication check failed, continue as anonymous user
      // This is acceptable for this public endpoint
      logError("GET /api/articles/:id - Auth check", authError);
    }

    // Step 3: Call service to fetch article detail
    const article = await getArticleDetail(supabase, articleId, userId);

    // Step 4: Handle not found
    if (!article) {
      return createJsonResponse(createErrorResponse("NOT_FOUND", "Article not found"), 404);
    }

    // Step 5: Return success response with appropriate cache headers
    const cacheHeaders: HeadersInit = {
      "Content-Type": "application/json",
    };

    // Cache public content for 5 minutes, don't cache user-specific data
    if (!userId) {
      cacheHeaders["Cache-Control"] = "public, max-age=300, stale-while-revalidate=600";
    } else {
      // User-specific data (includes completion status)
      cacheHeaders["Cache-Control"] = "private, no-cache";
    }

    return new Response(JSON.stringify(article), {
      status: 200,
      headers: cacheHeaders,
    });
  } catch (error) {
    // Step 6: Handle unexpected errors
    logError("GET /api/articles/:id", error, {
      articleId: context.params.id,
      url: context.request.url,
    });

    // Return generic error response
    return createJsonResponse(
      createErrorResponse("INTERNAL_SERVER_ERROR", "An unexpected error occurred while retrieving the article"),
      500
    );
  }
}



================================================
FILE: src/pages/api/articles/index.ts
================================================
/**
 * GET /api/articles
 * 
 * Lists articles with optional filtering, sorting, and pagination.
 * Public endpoint accessible to both authenticated and anonymous users.
 * Authenticated users can optionally include their completion status.
 */

import type { APIContext } from 'astro';
import { z } from 'zod';
import { listArticles } from '../../../lib/services/article.service';
import {
  createErrorResponse,
  createJsonResponse,
  formatZodError,
  logError,
} from '../../../lib/utils/error-handler';

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating query parameters
 * Includes type coercion for numbers and booleans from URL query strings
 */
const ListArticlesQuerySchema = z.object({
  level: z.enum(['BEGINNER', 'INTERMEDIATE', 'EXPERIENCED']).optional(),
  sort: z.enum(['difficulty_asc', 'newest']).optional().default('difficulty_asc'),
  page: z.coerce.number().int().positive().optional().default(1),
  limit: z.coerce.number().int().min(1).max(100).optional().default(20),
  include_completed: z.coerce.boolean().optional().default(true),
});

/**
 * GET handler for listing articles
 * 
 * Query Parameters:
 * - level: Filter by difficulty level (BEGINNER, INTERMEDIATE, EXPERIENCED)
 * - sort: Sort order (difficulty_asc, newest)
 * - page: Page number (default: 1)
 * - limit: Items per page (default: 20, max: 100)
 * - include_completed: Include completion status for authenticated users (default: true)
 * 
 * Returns:
 * - 200: Success with articles list and pagination metadata
 * - 400: Invalid query parameters
 * - 500: Internal server error
 */
export async function GET(context: APIContext): Promise<Response> {
  try {
    // Extract query parameters from URL
    const url = new URL(context.request.url);
    const queryParams = Object.fromEntries(url.searchParams.entries());

    // Validate query parameters using Zod schema
    const validationResult = ListArticlesQuerySchema.safeParse(queryParams);

    if (!validationResult.success) {
      return createJsonResponse(
        formatZodError(validationResult.error),
        400
      );
    }

    const validatedParams = validationResult.data;

    // Check if user is authenticated (optional for this endpoint)
    const supabase = context.locals.supabase;
    let userId: string | undefined;

    try {
      const { data: { user } } = await supabase.auth.getUser();
      userId = user?.id;
    } catch (authError) {
      // Authentication check failed, continue as anonymous user
      // This is acceptable for this public endpoint
      logError('GET /api/articles - Auth check', authError);
    }

    // Call service to fetch articles
    const response = await listArticles(
      supabase,
      validatedParams,
      userId
    );

    // Set cache headers based on authentication status
    const cacheHeaders: HeadersInit = {
      'Content-Type': 'application/json',
    };

    // Cache anonymous requests for 10 minutes
    if (!userId) {
      cacheHeaders['Cache-Control'] = 'public, max-age=600';
    } else {
      // Don't cache authenticated requests (user-specific data)
      cacheHeaders['Cache-Control'] = 'private, no-cache';
    }

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: cacheHeaders,
    });

  } catch (error) {
    // Log the error with context
    logError('GET /api/articles', error, {
      url: context.request.url,
    });

    // Return generic error response
    return createJsonResponse(
      createErrorResponse(
        'INTERNAL_SERVER_ERROR',
        'An unexpected error occurred while fetching articles'
      ),
      500
    );
  }
}



================================================
FILE: src/pages/api/articles/[id]/complete.ts
================================================
/**
 * POST /api/articles/:id/complete
 *
 * Records article completion for the authenticated user.
 * This endpoint is idempotent - calling it multiple times for the same article
 * will not create duplicate completion records.
 *
 * Authentication: Required
 */

import type { APIContext } from "astro";
import { z } from "zod";
import { completeArticle } from "../../../../lib/services/article.service";
import {
  createErrorResponse,
  createJsonResponse,
  formatZodError,
  logError,
} from "../../../../lib/utils/error-handler";

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating path parameters
 */
const ArticleIdParamSchema = z.object({
  id: z.string().uuid({ message: "Invalid article ID format" }),
});

/**
 * POST handler for recording article completion
 *
 * Path Parameters:
 * - id: UUID of the article to mark as completed
 *
 * Returns:
 * - 200: Already completed (idempotent response)
 * - 201: Successfully marked as completed (new record created)
 * - 400: Invalid UUID format
 * - 401: User not authenticated
 * - 404: Article not found
 * - 500: Internal server error
 */
export async function POST(context: APIContext): Promise<Response> {
  try {
    // Step 1: Validate path parameter
    const validationResult = ArticleIdParamSchema.safeParse(context.params);

    if (!validationResult.success) {
      return createJsonResponse(formatZodError(validationResult.error), 400);
    }

    const { id: articleId } = validationResult.data;

    // Step 2: Check authentication
    const supabase = context.locals.supabase;
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse("UNAUTHORIZED", "You must be logged in to complete articles"),
        401
      );
    }

    const userId = user.id;

    // Step 3: Call service to record completion
    try {
      const completionData = await completeArticle(supabase, articleId, userId);

      // Return appropriate status code based on whether record was created or already existed
      const statusCode = completionData.status === "created" ? 201 : 200;

      return new Response(JSON.stringify(completionData), {
        status: statusCode,
        headers: {
          "Content-Type": "application/json",
          // Don't cache user-specific completion data
          "Cache-Control": "private, no-cache",
        },
      });
    } catch (serviceError) {
      // Handle service-level errors
      if (serviceError instanceof Error && serviceError.message === "Article not found") {
        return createJsonResponse(
          createErrorResponse("NOT_FOUND", "Article not found"),
          404
        );
      }

      // Re-throw unexpected errors to be caught by outer handler
      throw serviceError;
    }
  } catch (error) {
    // Step 4: Handle unexpected errors
    logError("POST /api/articles/:id/complete", error, {
      articleId: context.params.id,
      url: context.request.url,
    });

    return createJsonResponse(
      createErrorResponse(
        "INTERNAL_SERVER_ERROR",
        "An unexpected error occurred while recording article completion"
      ),
      500
    );
  }
}



================================================
FILE: src/pages/api/auth/login.ts
================================================
import type { APIRoute } from 'astro';
import { z } from 'zod';
import { createSupabaseServerInstance } from '../../../db/supabase.client.ts';
import { supabaseAdminClient } from '../../../db/supabase.admin.ts';
import { createJsonResponse, formatZodError, createErrorResponse, logError } from '../../../lib/utils/error-handler.ts';
import type { LoginResponseDTO, ProfileDTO } from '../../../types.ts';

/**
 * Disable prerendering for this API route
 */
export const prerender = false;

/**
 * Zod schema for login request validation
 */
const LoginBodySchema = z.object({
  identifier: z.string().min(1, 'Email or username is required'),
  password: z.string().min(1, 'Password is required'),
});

/**
 * Check if string is a valid email format
 */
function isEmailFormat(identifier: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(identifier);
}

/**
 * Resolve identifier (username or email) to email address
 * If identifier is email format, return it directly
 * If identifier is username, look up user in profiles and get email via admin client
 * 
 * @returns email address or null if not found
 */
async function resolveIdentifierToEmail(identifier: string, supabase: ReturnType<typeof createSupabaseServerInstance>): Promise<string | null> {
  // If identifier looks like an email, use it directly
  if (isEmailFormat(identifier)) {
    return identifier;
  }

  // Otherwise, treat as username and look up in profiles
  // Username is case-sensitive, alphanumeric only, no whitespace
  const { data: profile, error } = await supabase
    .from('profiles')
    .select('id')
    .eq('username', identifier)
    .single();

  if (error || !profile) {
    // Username not found - return null (don't reveal this to client)
    return null;
  }

  // Get user email from auth.users via admin client
  const { data: authUser, error: authError } = await supabaseAdminClient.auth.admin.getUserById(profile.id);

  if (authError || !authUser.user) {
    logError('POST /api/auth/login - getUserById', authError, { userId: profile.id });
    return null;
  }

  return authUser.user.email ?? null;
}

/**
 * POST /api/auth/login
 * 
 * Authenticates user with email or username + password
 * Returns user and profile information
 * Session is established via HttpOnly cookies
 * 
 * Security: Returns generic error for invalid credentials to prevent account enumeration
 */
export const POST: APIRoute = async ({ request, cookies }) => {
  try {
    // Parse and validate request body
    const body = await request.json();
    const validation = LoginBodySchema.safeParse(body);

    if (!validation.success) {
      return createJsonResponse(formatZodError(validation.error), 400);
    }

    const { identifier, password } = validation.data;

    // Create request-scoped Supabase client
    const supabase = createSupabaseServerInstance({
      cookies,
      headers: request.headers,
    });

    // Resolve identifier to email
    const email = await resolveIdentifierToEmail(identifier, supabase);

    if (!email) {
      // Username/email not found - return generic error
      return createJsonResponse(
        createErrorResponse('UNAUTHORIZED', 'Invalid credentials'),
        401
      );
    }

    // Attempt login with email and password
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (authError || !authData.user) {
      // Invalid password or other auth error - return generic error
      logError('POST /api/auth/login - signInWithPassword', authError, { email });
      return createJsonResponse(
        createErrorResponse('UNAUTHORIZED', 'Invalid credentials'),
        401
      );
    }

    // Fetch user profile from database
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('id, username, selected_level, created_at, updated_at')
      .eq('id', authData.user.id)
      .single();

    if (profileError || !profile) {
      logError('POST /api/auth/login - fetch profile', profileError, { userId: authData.user.id });
      return createJsonResponse(
        createErrorResponse('INTERNAL_SERVER_ERROR', 'Failed to fetch user profile'),
        500
      );
    }

    // Return success response (session is in HttpOnly cookies)
    const response: LoginResponseDTO = {
      user: {
        id: authData.user.id,
        email: authData.user.email ?? '',
      },
      profile: profile as ProfileDTO,
    };

    return createJsonResponse(response, 200);
  } catch (error) {
    logError('POST /api/auth/login', error);
    return createJsonResponse(
      createErrorResponse('INTERNAL_SERVER_ERROR', 'An unexpected error occurred'),
      500
    );
  }
};



================================================
FILE: src/pages/api/auth/logout.ts
================================================
import type { APIRoute } from 'astro';
import { createSupabaseServerInstance } from '../../../db/supabase.client.ts';
import { createJsonResponse, createErrorResponse, logError } from '../../../lib/utils/error-handler.ts';
import type { LogoutResponseDTO } from '../../../types.ts';

/**
 * Disable prerendering for this API route
 */
export const prerender = false;

/**
 * POST /api/auth/logout
 * 
 * Logs out the current user by ending their session
 * Clears authentication cookies and redirects to home page
 */
export const POST: APIRoute = async ({ request, cookies, redirect }) => {
  try {
    // Create request-scoped Supabase client
    const supabase = createSupabaseServerInstance({
      cookies,
      headers: request.headers,
    });

    // Sign out the user (clears session and removes cookies)
    const { error } = await supabase.auth.signOut();

    if (error) {
      logError('POST /api/auth/logout - signOut', error);
      return createJsonResponse(
        createErrorResponse('INTERNAL_SERVER_ERROR', 'Failed to log out'),
        500
      );
    }

    // Redirect to home page after successful logout
    return redirect('/', 303);
  } catch (error) {
    logError('POST /api/auth/logout', error);
    return createJsonResponse(
      createErrorResponse('INTERNAL_SERVER_ERROR', 'An unexpected error occurred'),
      500
    );
  }
};



================================================
FILE: src/pages/api/auth/signup.ts
================================================
import type { APIRoute } from 'astro';
import { z } from 'zod';
import { createSupabaseServerInstance } from '../../../db/supabase.client.ts';
import { supabaseAdminClient } from '../../../db/supabase.admin.ts';
import { createJsonResponse, formatZodError, createErrorResponse, logError } from '../../../lib/utils/error-handler.ts';
import type { SignUpResponseDTO, DifficultyLevel } from '../../../types.ts';

/**
 * Disable prerendering for this API route
 */
export const prerender = false;

/**
 * Zod schema for signup request validation
 */
const SignUpBodySchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Enter a valid email address'),
  username: z
    .string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters')
    .regex(
      /^[a-zA-Z0-9_]+$/,
      'Username can only contain letters, numbers, and underscores'
    ),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters'),
  selected_level: z.enum(['BEGINNER', 'INTERMEDIATE', 'EXPERIENCED'], {
    errorMap: () => ({ message: 'Select a valid starting level' }),
  }),
});

/**
 * POST /api/auth/signup
 * 
 * Creates a new user account with:
 * - Supabase Auth user (email + password)
 * - Profile record (username + selected_level)
 * 
 * Returns user and profile information
 * Session is established via HttpOnly cookies
 * 
 * Security:
 * - Validates all input fields
 * - Checks for duplicate username (case-sensitive)
 * - Handles duplicate email via Supabase Auth error
 */
export const POST: APIRoute = async ({ request, cookies }) => {
  try {
    // Parse and validate request body
    const body = await request.json();
    const validation = SignUpBodySchema.safeParse(body);

    if (!validation.success) {
      return createJsonResponse(formatZodError(validation.error), 400);
    }

    const { email, username, password, selected_level } = validation.data;

    // Create request-scoped Supabase client
    const supabase = createSupabaseServerInstance({
      cookies,
      headers: request.headers,
    });

    // Check for duplicate username (case-sensitive)
    const { data: existingProfile, error: profileCheckError } = await supabase
      .from('profiles')
      .select('username')
      .eq('username', username)
      .maybeSingle();

    if (profileCheckError) {
      logError('POST /api/auth/signup - check username', profileCheckError, { username });
      return createJsonResponse(
        createErrorResponse('INTERNAL_SERVER_ERROR', 'Failed to check username availability'),
        500
      );
    }

    if (existingProfile) {
      return createJsonResponse(
        createErrorResponse(
          'CONFLICT',
          'Username is already taken',
          { username: 'This username is already taken' }
        ),
        409
      );
    }

    // Create auth user with Supabase Auth
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
    });

    if (authError || !authData.user) {
      // Handle duplicate email error
      if (authError?.message?.includes('already registered')) {
        return createJsonResponse(
          createErrorResponse(
            'CONFLICT',
            'Email is already registered',
            { email: 'This email is already registered' }
          ),
          409
        );
      }

      logError('POST /api/auth/signup - signUp', authError, { email });
      return createJsonResponse(
        createErrorResponse('INTERNAL_SERVER_ERROR', 'Failed to create account'),
        500
      );
    }

    // Create profile record
    // Note: We use admin client here because the user was just created
    // and may not have proper session tokens yet for RLS policies
    const { data: profile, error: profileError } = await supabaseAdminClient
      .from('profiles')
      .insert({
        id: authData.user.id,
        username,
        selected_level: selected_level as DifficultyLevel,
      })
      .select('id, username, selected_level, created_at, updated_at')
      .single();

    if (profileError || !profile) {
      // Profile creation failed - clean up auth user
      logError('POST /api/auth/signup - create profile', profileError, { userId: authData.user.id });

      // Attempt to delete the auth user to avoid orphaned accounts
      await supabaseAdminClient.auth.admin.deleteUser(authData.user.id);

      return createJsonResponse(
        createErrorResponse('INTERNAL_SERVER_ERROR', 'Failed to create user profile'),
        500
      );
    }

    // Return success response (session is in HttpOnly cookies)
    const response: SignUpResponseDTO = {
      user: {
        id: authData.user.id,
        email: authData.user.email ?? '',
      },
      profile: {
        id: profile.id,
        username: profile.username,
        selected_level: profile.selected_level,
        created_at: profile.created_at,
        updated_at: profile.updated_at,
      },
    };

    return createJsonResponse(response, 201);
  } catch (error) {
    logError('POST /api/auth/signup', error);
    return createJsonResponse(
      createErrorResponse('INTERNAL_SERVER_ERROR', 'An unexpected error occurred'),
      500
    );
  }
};



================================================
FILE: src/pages/api/cookbook/[id].ts
================================================
/**
 * /api/cookbook/:id
 *
 * Handles individual cookbook entry operations:
 * - GET: Retrieves a single cookbook entry by ID
 * - PATCH: Updates an existing cookbook entry
 * - DELETE: Deletes a cookbook entry
 *
 * Requires authentication - returns 401 if user is not logged in.
 * Returns 404 if entry doesn't exist or doesn't belong to user.
 */

import type { APIContext } from 'astro';
import { z } from 'zod';
import {
  getCookbookEntry,
  updateCookbookEntry,
  deleteCookbookEntry,
} from '../../../lib/services/cookbook.service';
import {
  createErrorResponse,
  createJsonResponse,
  formatZodError,
  logError,
} from '../../../lib/utils/error-handler';
import type { UpdateCookbookEntryCommand } from '../../../types';

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating UUID path parameter
 */
const UuidParamSchema = z.string().uuid('Invalid entry ID format');

/**
 * Zod schema for validating PATCH /api/cookbook/:id request body
 * All fields are optional, but at least one must be provided
 */
const UpdateCookbookEntryBodySchema = z
  .object({
    url: z.string().url('Must be a valid URL').optional(),
    title: z.string().min(1, 'Title cannot be empty').optional(),
    notes: z.string().optional(),
  })
  .refine((data) => data.url !== undefined || data.title !== undefined || data.notes !== undefined, {
    message: 'At least one field (url, title, or notes) must be provided',
  });

/**
 * GET handler for retrieving a single cookbook entry
 *
 * Path Parameters:
 * - id: UUID of the cookbook entry
 *
 * Returns:
 * - 200: Success with cookbook entry data
 * - 400: Invalid UUID format
 * - 401: User not authenticated
 * - 404: Entry not found or doesn't belong to user
 * - 500: Internal server error
 */
export async function GET(context: APIContext): Promise<Response> {
  try {
    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse(
          'UNAUTHORIZED',
          'Authentication required to access cookbook entries'
        ),
        401
      );
    }

    // Validate path parameter (entry ID)
    const entryId = context.params.id;
    const validationResult = UuidParamSchema.safeParse(entryId);

    if (!validationResult.success) {
      return createJsonResponse(
        createErrorResponse(
          'VALIDATION_ERROR',
          'Invalid entry ID format',
          { id: validationResult.error.errors[0].message }
        ),
        400
      );
    }

    const validatedId = validationResult.data;

    // Call service to fetch cookbook entry
    const entry = await getCookbookEntry(supabase, user.id, validatedId);

    // Return 404 if entry not found or doesn't belong to user
    if (!entry) {
      return createJsonResponse(
        createErrorResponse(
          'NOT_FOUND',
          'Cookbook entry not found'
        ),
        404
      );
    }

    // Return successful response
    return new Response(JSON.stringify(entry), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'private, no-cache',
      },
    });
  } catch (error) {
    // Log error with context
    logError('GET /api/cookbook/:id', error, {
      entryId: context.params.id,
    });

    // Return generic 500 error
    return createJsonResponse(
      createErrorResponse(
        'INTERNAL_SERVER_ERROR',
        'An unexpected error occurred while fetching cookbook entry'
      ),
      500
    );
  }
}

/**
 * PATCH handler for updating a cookbook entry
 *
 * Path Parameters:
 * - id: UUID of the cookbook entry
 *
 * Request Body (at least one field required):
 * - url: Valid URL string (optional)
 * - title: Non-empty string (optional)
 * - notes: String (optional)
 *
 * Returns:
 * - 200: Success with updated cookbook entry
 * - 400: Invalid UUID format or invalid request body
 * - 401: User not authenticated
 * - 404: Entry not found or doesn't belong to user
 * - 500: Internal server error
 */
export async function PATCH(context: APIContext): Promise<Response> {
  try {
    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse(
          'UNAUTHORIZED',
          'Authentication required to update cookbook entries'
        ),
        401
      );
    }

    // Validate path parameter (entry ID)
    const entryId = context.params.id;
    const idValidationResult = UuidParamSchema.safeParse(entryId);

    if (!idValidationResult.success) {
      return createJsonResponse(
        createErrorResponse(
          'VALIDATION_ERROR',
          'Invalid entry ID format',
          { id: idValidationResult.error.errors[0].message }
        ),
        400
      );
    }

    const validatedId = idValidationResult.data;

    // Parse request body
    let requestBody: unknown;
    try {
      requestBody = await context.request.json();
    } catch (parseError) {
      return createJsonResponse(
        createErrorResponse(
          'VALIDATION_ERROR',
          'Invalid JSON in request body'
        ),
        400
      );
    }

    // Validate request body with Zod
    const bodyValidationResult = UpdateCookbookEntryBodySchema.safeParse(requestBody);

    if (!bodyValidationResult.success) {
      return createJsonResponse(formatZodError(bodyValidationResult.error), 400);
    }

    const validatedBody = bodyValidationResult.data;

    // Prepare command object
    const command: UpdateCookbookEntryCommand = {
      url: validatedBody.url,
      title: validatedBody.title,
      notes: validatedBody.notes,
    };

    // Call service to update cookbook entry
    const updatedEntry = await updateCookbookEntry(supabase, user.id, validatedId, command);

    // Return 404 if entry not found or doesn't belong to user
    if (!updatedEntry) {
      return createJsonResponse(
        createErrorResponse(
          'NOT_FOUND',
          'Cookbook entry not found'
        ),
        404
      );
    }

    // Return successful response
    return new Response(JSON.stringify(updatedEntry), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'private, no-cache',
      },
    });
  } catch (error) {
    // Log error with context
    logError('PATCH /api/cookbook/:id', error, {
      entryId: context.params.id,
    });

    // Return generic 500 error
    return createJsonResponse(
      createErrorResponse(
        'INTERNAL_SERVER_ERROR',
        'An unexpected error occurred while updating cookbook entry'
      ),
      500
    );
  }
}

/**
 * DELETE handler for deleting a cookbook entry
 *
 * Path Parameters:
 * - id: UUID of the cookbook entry
 *
 * Returns:
 * - 200: Success with deletion confirmation message
 * - 400: Invalid UUID format
 * - 401: User not authenticated
 * - 404: Entry not found or doesn't belong to user
 * - 500: Internal server error
 */
export async function DELETE(context: APIContext): Promise<Response> {
  try {
    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse(
          'UNAUTHORIZED',
          'Authentication required to delete cookbook entries'
        ),
        401
      );
    }

    // Validate path parameter (entry ID)
    const entryId = context.params.id;
    const validationResult = UuidParamSchema.safeParse(entryId);

    if (!validationResult.success) {
      return createJsonResponse(
        createErrorResponse(
          'VALIDATION_ERROR',
          'Invalid entry ID format',
          { id: validationResult.error.errors[0].message }
        ),
        400
      );
    }

    const validatedId = validationResult.data;

    // Call service to delete cookbook entry
    const wasDeleted = await deleteCookbookEntry(supabase, user.id, validatedId);

    // Return 404 if entry not found or doesn't belong to user
    if (!wasDeleted) {
      return createJsonResponse(
        createErrorResponse(
          'NOT_FOUND',
          'Cookbook entry not found'
        ),
        404
      );
    }

    // Return successful response with confirmation message
    return new Response(
      JSON.stringify({ message: 'Cookbook entry deleted successfully' }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'private, no-cache',
        },
      }
    );
  } catch (error) {
    // Log error with context
    logError('DELETE /api/cookbook/:id', error, {
      entryId: context.params.id,
    });

    // Return generic 500 error
    return createJsonResponse(
      createErrorResponse(
        'INTERNAL_SERVER_ERROR',
        'An unexpected error occurred while deleting cookbook entry'
      ),
      500
    );
  }
}



================================================
FILE: src/pages/api/cookbook/index.ts
================================================
/**
 * /api/cookbook
 *
 * Handles cookbook entry operations:
 * - GET: Lists cookbook entries saved by the authenticated user
 * - POST: Creates a new cookbook entry
 *
 * Requires authentication - returns 401 if user is not logged in.
 */

import type { APIContext } from 'astro';
import { z } from 'zod';
import { listCookbookEntries, createCookbookEntry } from '../../../lib/services/cookbook.service';
import {
  createErrorResponse,
  createJsonResponse,
  formatZodError,
  logError,
} from '../../../lib/utils/error-handler';
import type { CreateCookbookEntryCommand } from '../../../types';

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating query parameters for GET /api/cookbook
 * Includes type coercion for numbers from URL query strings and default values
 */
const ListCookbookEntriesQuerySchema = z.object({
  sort: z.enum(['newest', 'oldest', 'title_asc']).optional().default('newest'),
  page: z.coerce.number().int().positive().optional().default(1),
  limit: z.coerce.number().int().min(1).max(100).optional().default(20),
});

/**
 * Zod schema for validating POST /api/cookbook request body
 * Validates required url and title fields, with optional notes
 */
const CreateCookbookEntryBodySchema = z.object({
  url: z.string().url('Must be a valid URL'),
  title: z.string().min(1, 'Title is required and cannot be empty'),
  notes: z.string().optional(),
});

/**
 * GET handler for listing cookbook entries
 *
 * Query Parameters:
 * - sort: Sort order (newest, oldest, title_asc) - default: newest
 * - page: Page number (default: 1)
 * - limit: Items per page (default: 20, max: 100)
 *
 * Returns:
 * - 200: Success with cookbook entries list and pagination metadata
 * - 400: Invalid query parameters
 * - 401: User not authenticated
 * - 500: Internal server error
 */
export async function GET(context: APIContext): Promise<Response> {
  try {
    // Parse query parameters from URL
    const url = new URL(context.request.url);
    const queryParams = Object.fromEntries(url.searchParams.entries());

    // Validate query parameters with Zod
    const validationResult = ListCookbookEntriesQuerySchema.safeParse(queryParams);

    if (!validationResult.success) {
      return createJsonResponse(formatZodError(validationResult.error), 400);
    }

    const validatedParams = validationResult.data;

    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse(
          'UNAUTHORIZED',
          'Authentication required to access cookbook entries'
        ),
        401
      );
    }

    // Call service to fetch cookbook entries
    const response = await listCookbookEntries(supabase, validatedParams, user.id);

    // Return successful response with cache control headers for user-specific data
    return new Response(JSON.stringify(response), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'private, no-cache',
      },
    });
  } catch (error) {
    // Log error with context
    logError('GET /api/cookbook', error, {
      url: context.request.url,
    });

    // Return generic 500 error (don't leak internal details)
    return createJsonResponse(
      createErrorResponse(
        'INTERNAL_SERVER_ERROR',
        'An unexpected error occurred while fetching cookbook entries'
      ),
      500
    );
  }
}

/**
 * POST handler for creating a new cookbook entry
 *
 * Request Body:
 * - url: Valid URL string (required)
 * - title: Non-empty string (required)
 * - notes: String (optional)
 *
 * Returns:
 * - 201: Success with created cookbook entry
 * - 400: Invalid request body
 * - 401: User not authenticated
 * - 500: Internal server error
 */
export async function POST(context: APIContext): Promise<Response> {
  try {
    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse(
          'UNAUTHORIZED',
          'Authentication required to create cookbook entries'
        ),
        401
      );
    }

    // Parse request body
    let requestBody: unknown;
    try {
      requestBody = await context.request.json();
    } catch (parseError) {
      return createJsonResponse(
        createErrorResponse(
          'VALIDATION_ERROR',
          'Invalid JSON in request body'
        ),
        400
      );
    }

    // Validate request body with Zod
    const validationResult = CreateCookbookEntryBodySchema.safeParse(requestBody);

    if (!validationResult.success) {
      return createJsonResponse(formatZodError(validationResult.error), 400);
    }

    const validatedBody = validationResult.data;

    // Prepare command object
    const command: CreateCookbookEntryCommand = {
      url: validatedBody.url,
      title: validatedBody.title,
      notes: validatedBody.notes,
    };

    // Call service to create cookbook entry
    const createdEntry = await createCookbookEntry(supabase, user.id, command);

    // Return successful response with 201 Created status
    return new Response(JSON.stringify(createdEntry), {
      status: 201,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'private, no-cache',
      },
    });
  } catch (error) {
    // Log error with context
    logError('POST /api/cookbook', error, {
      url: context.request.url,
    });

    // Return generic 500 error (don't leak internal details)
    return createJsonResponse(
      createErrorResponse(
        'INTERNAL_SERVER_ERROR',
        'An unexpected error occurred while creating cookbook entry'
      ),
      500
    );
  }
}



================================================
FILE: src/pages/api/progress/summary.ts
================================================
/**
 * /api/progress/summary
 *
 * Handles user progress tracking:
 * - GET: Returns progress summary across all difficulty levels
 *
 * Requires authentication - returns 401 if user is not logged in.
 */

import type { APIContext } from 'astro';
import { getUserProgressSummary } from '../../../lib/services/progress.service';
import {
  createErrorResponse,
  createJsonResponse,
  logError,
} from '../../../lib/utils/error-handler';

// Disable prerendering for this API route
export const prerender = false;

/**
 * GET handler for fetching user progress summary
 *
 * Returns:
 * - 200: Success with UserProgressSummaryDTO
 * - 401: User not authenticated
 * - 500: Internal server error
 */
export async function GET(context: APIContext): Promise<Response> {
  try {
    // Authenticate user using Supabase from context.locals
    const supabase = context.locals.supabase;
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    // Return 401 if authentication fails or user is missing
    if (authError || !user) {
      return createJsonResponse(
        createErrorResponse('UNAUTHORIZED', 'Authentication required to view progress'),
        401
      );
    }

    // Get user's profile to determine selected level
    const profile = context.locals.profile;
    if (!profile) {
      return createJsonResponse(
        createErrorResponse('UNAUTHORIZED', 'Profile not found'),
        401
      );
    }

    // Call service to fetch progress summary
    const progressSummary = await getUserProgressSummary(
      supabase,
      user.id,
      profile.selected_level
    );

    // Return successful response
    return new Response(JSON.stringify(progressSummary), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'private, no-cache',
      },
    });
  } catch (error: unknown) {
    // Handle service-level errors (thrown as ApiErrorResponse)
    if (
      error &&
      typeof error === 'object' &&
      'error' in error &&
      typeof error.error === 'object' &&
      error.error !== null &&
      'code' in error.error
    ) {
      const apiError = error as { error: { code: string; message: string } };
      const statusMap: Record<string, number> = {
        UNAUTHORIZED: 401,
        INTERNAL_SERVER_ERROR: 500,
      };
      const status = statusMap[apiError.error.code] || 500;
      return createJsonResponse(error, status);
    }

    // Log unexpected errors
    logError('GET /api/progress/summary', error, { userId: context.locals.user?.id });

    // Return generic 500 error
    return createJsonResponse(
      createErrorResponse('INTERNAL_SERVER_ERROR', 'An unexpected error occurred'),
      500
    );
  }
}



================================================
FILE: src/pages/api/tutorials/[id].ts
================================================
/**
 * GET /api/tutorials/:id
 *
 * Retrieves comprehensive information about a specific tutorial.
 * Public endpoint accessible to both authenticated and anonymous users.
 * Authenticated users receive their completion status and completion timestamp.
 */

import type { APIContext } from "astro";
import { z } from "zod";
import { getTutorialDetail } from "../../../lib/services/tutorial.service";
import { createErrorResponse, createJsonResponse, formatZodError, logError } from "../../../lib/utils/error-handler";

// Disable prerendering for this API route
export const prerender = false;

/**
 * Zod schema for validating path parameters
 * Ensures the tutorial ID is a valid UUID format
 */
const TutorialIdParamSchema = z.object({
  id: z.string().uuid({ message: "Invalid tutorial ID format" }),
});

/**
 * GET handler for retrieving a specific tutorial
 *
 * Path Parameters:
 * - id: UUID of the tutorial to retrieve
 *
 * Returns:
 * - 200: Success with full tutorial details
 * - 400: Invalid UUID format
 * - 404: Tutorial not found
 * - 500: Internal server error
 */
export async function GET(context: APIContext): Promise<Response> {
  try {
    // Step 1: Extract and validate path parameter
    const validationResult = TutorialIdParamSchema.safeParse(context.params);

    if (!validationResult.success) {
      return createJsonResponse(formatZodError(validationResult.error), 400);
    }

    const { id: tutorialId } = validationResult.data;

    // Step 2: Check if user is authenticated (optional for this endpoint)
    const supabase = context.locals.supabase;
    let userId: string | undefined;

    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      userId = user?.id;
    } catch (authError) {
      // Authentication check failed, continue as anonymous user
      // This is acceptable for this public endpoint
      logError("GET /api/tutorials/:id - Auth check", authError);
    }

    // Step 3: Call service to fetch tutorial detail
    const tutorial = await getTutorialDetail(supabase, tutorialId, userId);

    // Step 4: Handle not found
    if (!tutorial) {
      return createJsonResponse(createErrorResponse("NOT_FOUND", "Tutorial not found"), 404);
    }

    // Step 5: Return success response with appropriate cache headers
    const cacheHeaders: HeadersInit = {
      "Content-Type": "application/json",
    };

    // Cache public content for 5 minutes, don't cache user-specific data
    if (!userId) {
      cacheHeaders["Cache-Control"] = "public, max-age=300, stale-while-reval
</kod_projektu>

<stos_technologiczny>
@tech-stack.md
</stos_technologiczny>

Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu, uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
   - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
   - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
   - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
   - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:
- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Przedstaw ten plan w formacie Markdown i zapisz go do pliku ./.ai/test-plan.md